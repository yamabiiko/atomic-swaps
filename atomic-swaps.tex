\documentclass{article}      	% Style of the document                     
\usepackage{fullpage}
\usepackage{amsmath,amsthm}     	   	% Maths    
\newtheorem{definition}{Definition}                                      
\usepackage[utf8]{inputenc}	% UTF-8 characters                                               
\usepackage[T1]{fontenc}    	% Tuki ääkkösille (Finnish names don't cause problems)                                            
\usepackage{parskip}        		% Linebreak between paragraphs                
\usepackage{svg}
\usepackage{graphicx}       		% Graphics package for adding figures                        
\usepackage{epstopdf}       		% Possibility to add *.eps figures
 \usepackage{ dsfont }            % Symbol for real numbers
\usepackage{extarrows}
\usepackage{float}
\usepackage{makeidx}
\usepackage{enumitem}        % possibility to label list items by alphabet
\usepackage[a4paper, top=0.5in]{geometry}
\newcommand{\M}[1]{\ensuremath{\text{\texttt{#1}}}}
\usepackage[
    lambda,
    operators,
    advantage,
    sets,
    adversary,
    landau,
    probability,
    notions,
    logic,
    ff,
    mm,
    primitives,
    events,
    complexity,
    asymptotics,
    keys]{cryptocode}

\usepackage{todonotes}

 \usepackage{amsmath,amsfonts,graphicx,amssymb,amsthm}


\usepackage[bookmarksdepth=2,draft=false]{hyperref}
\hypersetup{colorlinks=true,linkcolor={red!50!black},citecolor=darkgray,linkcolor=darkgray}
\usepackage[capitalize]{cleveref}

\mathchardef\mhyphen="2D

 %% general
\mathchardef\mhyphen="2D
\newcommand{\fdv}{\mathcal{F}}
\newcommand{\tdv}{\mathcal{T}}
\newcommand{\vdv}{\mathcal{V}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\ID}{\mathcal{I}}
\newcommand{\bits}[1][]{\{0,1\}^{#1}}
\renewcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\mat}[1]{\mathbf{#1}}
\newcommand{\inner}[2]{\langle #1, #2 \rangle}
\newcommand{\transpose}{\mathtt{T}}
\newcommand{\round}[1]{\lfloor #1 \rceil}
\renewcommand{\dist}{\mathsf{dist}}
\renewcommand{\Pr}[2][]{{\text{Pr}_{#1}\left[#2\right]}}
\newcommand{\Exp}[2][]{{\mathbb{E}_{#1}\left[#2\right]}}
\newcommand{\mathcm}[2][1cm]{\hspace{#1}{\mbox{/\!\!/ } \text{\scriptsize#2}}}

%% lattice problems
\newcommand{\SIS}{\mathsf{SIS}}
\newcommand{\ISIS}{\mathsf{ISIS}}
\newcommand{\nfSIS}{\mathsf{nfSIS}}
\newcommand{\dSIS}{\mathsf{dSIS}}
\newcommand{\LWE}{\mathsf{LWE}}
\newcommand{\nfLWE}{\mathsf{nfLWE}}
\newcommand{\nfdLWE}{\mathsf{nfdLWE}}
\newcommand{\sLWE}{\mathsf{sLWE}}
\newcommand{\dLWE}{\mathsf{dLWE}}
\newcommand{\SVP}{\mathsf{SVP}}
\newcommand{\CVP}{\mathsf{CVP}}
\newcommand{\SIVP}{\mathsf{SIVP}}
\newcommand{\GapSVP}{\mathsf{GapSVP}}
\newcommand{\BDD}{\mathsf{BDD}}
\newcommand{\NTRU}{\mathsf{NTRU}}
\newcommand{\sNTRU}{\mathsf{sNTRU}}
\newcommand{\dNTRU}{\mathsf{dNTRU}}

%% lattice macros
\newcommand{\TT}{\mathbb{T}}
\newcommand{\ring}{\mathcal{R}}
\newcommand{\lattice}{\mathcal{L}}
\newcommand{\piped}{\mathcal{P}}
\newcommand{\ball}{\mathcal{B}}
\newcommand{\Hyb}{\mathsf{Hyb}}
\newcommand{\lspan}{\mathsf{span}}
\newcommand{\rank}{\mathsf{rank}}
\newcommand{\lsb}{\mathsf{LSB}}
\newcommand{\pubparam}{\mathsf{pp}}

%% group macros

%% syntax
\newcommand{\mpk}{\mathsf{mpk}}
\newcommand{\msk}{\mathsf{msk}}
\newcommand{\msg}{\mathsf{msg}}
\newcommand{\rnd}{\mathsf{rnd}}
\newcommand{\ctxt}{\mathsf{ctxt}}
\newcommand{\com}{\mathsf{com}}
\newcommand{\td}{\mathsf{td}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\stmt}{\mathsf{stmt}}
\newcommand{\wit}{\mathsf{wit}}
\newcommand{\tx}{\mathsf{tx}}
\newcommand{\aux}{\mathsf{aux}}
\newcommand{\ek}{\mathsf{ek}}

\newcommand{\Setup}{\mathsf{Setup}}
\newcommand{\Commit}{\mathsf{Com}}
\newcommand{\TrapGen}{\mathsf{TrapGen}}
\newcommand{\SampD}{\mathsf{SampD}}
\newcommand{\SampPre}{\mathsf{SampPre}}
\newcommand{\Prove}{\mathsf{Prove}}
\newcommand{\Verify}{\mathsf{Verify}}
\newcommand{\val}{\mathsf{val}}

%% primitive/scheme name
\newcommand{\PKE}{\mathsf{PKE}}
\newcommand{\LTDF}{\mathsf{LTDF}}
\newcommand{\rsagen}{\mathsf{RSAGen}}
\newcommand{\rsa}{\mathsf{RSA}}
\newcommand{\LHE}{\mathsf{LHE}}
\newcommand{\CS}{\mathcal{CS}}
\newcommand{\NTRUEncrypt}{\mathsf{NTRUEncrypt}}

%% others
\newcommand{\oracle}{\mathcal{O}}
\newcommand{\pcas}{~\mathbf{as}~}

\newcommand{\polylog}[1][\secpar]{\mathsf{polylog}(#1)}

\newcommand{\indrsidcpa}{\mathrm{IND\$}\mhyphen\mathrm{sID}\mhyphen\mathrm{CPA}}
%\newcommand{\oplus}{\, \texttt{XOR} \,} % shorthand for typing the XOR operator in mathmode
\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}


\definecolor{cgreen}{RGB}{0, 153, 51}
\definecolor{cblue}{RGB}{0, 102, 204}
\definecolor{cyellow}{RGB}{255, 204, 0} 
\definecolor{cred}{RGB}{204, 51, 0} 

\newcommand{\commentline}[2]{%
    \tikz[remember picture, overlay]{
        \node [black,anchor=west,xshift=10pt] at (#1) {#2};
    }
}

\newcommand{\blockcomment}[3]{%
    \tikz[remember picture, overlay]{
        \draw [decorate,decoration={lineto,amplitude=10pt,mirror,raise=4pt},yshift=0pt,very thick,{#3}] 
        (#1) -- (#2) node [black,midway,xshift=10pt] {};
    }
}



\usepackage{biblatex}
\addbibresource{references.bib}

\begin{document}         
\author{Lorenzo Tucci}
\title{RingCCT: confidential commit transactions and atomic swaps}

\maketitle

\tableofcontents
\newpage

\section{Introduction}

\section{Commit transaction based atomic swaps}

Commit transactions can be easily realized by a blockchain using a public ledger model by modifying consensus rules, and require no additional scripting capabilities. 
A commit transaction allows to lock assets for a specified transfer until a certain timeout T, commiting to a secret value $x$ in $C$. If $C$ gets opened by broadcasting the revealed $x$ before timeout T, the transfer is completed unconditionally. 
After timeout T, the commit transaction is considered expired, unfreezing the assets and ignoring openings on $C$.

We further define the following routines for blockchains that support commitment transaction.
\begin{itemize}[topsep=0pt, itemsep=0pt, leftmargin=2em]
	\item $\mathbf{ctx}_{\mathbb{A}} := (\mathsf{tx_{\mathbb{A}}}, C) \gets \mathbf{CommitTx}_{(\mathbb{A})}(C, \mathsf{pk_{tx}}, \mathsf{pk_{rx}}, \mathsf{amnt}, \mathsf{T})$: creates an unsigned commit transaction paying $\mathsf{amnt}$ from $\mathsf{pk_{tx}}$ to $\mathsf{pk_{rx}}$ valid until time $\mathsf{T}$, whith  $\mathsf{amnt}$ being locked from being spent on transactions from $\mathsf{pk_{tx}}$ until $\mathsf{T}$. The transaction can be later finalized by opening and broadcasting $C$ through $\mathsf{RevTx}$.
    \item $ \mathbf{0/1} \gets \mathbf{RevTx}_{(\mathbb{A})}(\mathsf{sec}, \mathsf{ctx})$: open the (on-chain) committed transaction $\mathsf{ctx}$ by revealing the commited secret $\mathsf{sec}$. Return 0 if the opening fails or the timeout on $\mathsf{ctx}$ has expired. If the revealing succeeds, return 1 and finalize $\mathsf{ctx}$.
\end{itemize}

By assuming this functionality on both chains we can now realize the following atomic swap protocol.

\begin{figure}[H]
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (T, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    \mathsf{sec} \gets \mathbb{Z}_q \\
    (C_0, r) \gets \Pi_{\mathsf{PCom}}.\mathsf{Commit}(\mathsf{sec_0}) \\ % verify that sec_0 has been commited
    \mathsf{ctx_{(\mathbb{A})}} \gets \mathsf{CommitTx}_{(\mathbb{A})}(C_0, \mathsf{pk_{init}}, \mathsf{pk_{swp}}, \mathsf{amnt_a}, T + \Delta) \\
    \sigma_{\mathsf{ctx_{(\mathbb{A})}}} \gets \Pi_{\mathsf{DS(\mathbb{A})}}.\mathsf{Sign}(\mathsf{sk_{init}}, \mathsf{ctx}) \\
    \mathsf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{ctx}}, \mathsf{ctx}) \\
    \mathsf{\textbf{select}} \:\: \{ \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{timeout}(T) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{send}(\mathsf{ctx_{(\mathbb{A})}}) \\
    \qquad \textbf{do} \:\: \mathsf{ctx_{(\mathbb{B})}} \gets \mathsf{\textbf{wait}} \:\: \mathsf{GetLatestTx}_{(\mathbb{B})}(\mathsf{pk_{init}}) \\
    \qquad \mathsf{\textbf{while}} \:\: \mathsf{ctx}_{(\mathbb{B})}.C \neq C_0 \lor \mathsf{ctx}_{(\mathbb{B})}.T \neq T \lor \mathsf{res_1} \neq 1 \\ % verify that commit transaction is valid and accepted
    \qquad \mathsf{rtx_{swp(\mathbb{B})}} \gets \mathsf{RevTx}_{(\mathbb{B})}(\mathsf{sec}, \mathsf{ctx}) \\
    \quad \} \\
    \} \\
}
\end{pchstack}
\end{minipage}%
\hspace{0.4cm}
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (T, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    \mathsf{receive}(\mathsf{ctx_{(\mathbb{A})}}) \\
    \mathsf{res_0} \gets \mathsf{\textbf{wait}} \:\: \mathsf{WatchTx}_{(\mathbb{A})}(\mathsf{ctx}) \\
    \mathsf{\textbf{select}} \:\: \{ \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{timeout}(T) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{\textbf{if}} \:\: \mathsf{ctx_{(\mathbb{A})}}.T \neq T + \Delta \lor \mathsf{res_0} \neq 1 \\ % verify that commit transaction is valid and accepted
    \qquad \quad \mathsf{\textbf{return}} \perp \\
    \qquad \mathsf{ctx}_{(\mathbb{B})} \gets \mathsf{CommitTx}_{(\mathbb{B})}(C_0, \mathsf{pk_{init}}, \mathsf{pk_{swp}}, \mathsf{amnt_b}, T) \\
    \qquad \textbf{do} \:\: \mathsf{rtx_{swp(\mathbb{B})}} \gets \mathsf{\textbf{wait}} \:\: \mathsf{GetLatestTx}_{(\mathbb{A})}(\mathsf{pk_{swp}}) \\
    \qquad \textbf{while} \:\: \mathsf{rtx_{swp(\mathbb{B})}}.\mathsf{rev} = \perp \\
    \qquad \mathsf{sec} := \mathsf{rtx_{swp(\mathbb{B})}}.\mathsf{rev} \\
    \qquad \mathsf{rtx_{swp(\mathbb{A})}} \gets \mathsf{RevTx}_{(\mathbb{A})}(\mathsf{sec}, \mathsf{ctx}) \\
    \quad \} \\
    \} \\
}
\end{pchstack}
\end{minipage}%
\caption{Full protocol execution for $P_0$ and $P_1$, respectively left and right}
\end{figure}

\newpage
\section{RingCCT: Ring confidential commit transaction}

\textbf{Definition} A RingCCT scheme (Ring Commit Confidential Transactions) scheme consists of the PPT algorithms ($\mathsf{Setup,KGen,Tx,Vf,StExt,TxExt,SrcChk,TgtChk}$) whose interfaces are defined as follows.

\begin{itemize}
    \item $(\mathsf{pp,st}) \gets \mathsf{Setup}(1^\lambda)$: the setup algorithm generates the public parameters $\mathsf{st}$ and an initial global state $\mathsf{st}$.
    \item $(\mathsf{mpk},\mathsf{msk}) \gets \mathsf{KGen}(\mathsf{pp})$: the key generation algorithm generates a master public key $\mathsf{mpk}$ and a matching secret key $\mathsf{msk}$.
    \item $(\mathsf{sk},\mathsf{accd}) \gets \mathsf{KDer}(\mathsf{msk, \tau})$: the key derivation algorithm generates derives the keys-account data tuple given the master key $\mathsf{msk}$ owning the account and the token $\tau$ of the account.
    \item $(\mathsf{tx,TK}) \gets \mathsf{TxGen}(\mathsf{st},P,R,\mathcal{S},\mathcal{T})$: the transaction algorithm inputs a state $\mathsf{st}$, a predicate $P: \mathbb{Z}^S \times \mathbb{Z}^T \rightarrow \{0,1\}$, an index set R called the ring, a set of source accouts information $\mathcal{S} = \{\mathsf{ssk}_i, \mathsf{tsk}_i, \mathsf{rsk}_i, \mathsf{accd}_i\}_{i\in S}$ and some targets account information $\mathcal{T} = \{\mathsf{smpk}_i, \mathsf{tmpk}_i, \mathsf{rmpk}_i, \mathsf{accd}'_i\}_{i\in T}$; where $\mathsf{ssk,tsk,rsk}$ and $\mathsf{spk,tpk,rpk}$ are the source, target and recovery secret and public keys respectively. If source or target account is not commit based, only the source key pair is defined. Each account has some $\mathsf{accd} := (a,\mathsf{time})$ defined, where $a$ represents some amount and $\mathsf{time}$ sets a specific epoch timeout of the ownership of commit account by the target key pair, and empty otherwise. 
    \item $(b,\mathsf{st}') \gets \mathsf{Vf}(\mathsf{st,tx})$: The verification algorithm outputs a bit b deciding whether to accept or reject that the transaction $\mathsf{tx}$ is a valid relative to the state $\mathsf{st}$, outputting an updated state $\mathsf{st}'$ if the verification is sucessful.
\item $\mathsf{AC}_U \gets \mathsf{StExt}(\mathsf{st})$: The state extraction algorithm
extracts the set of universe accounts $\mathsf{AC}_U = \{\mathsf{ac}_i\}_{i \in U}$ encoded in the state $\mathsf{st}$.
\item $\mathsf{AC}_T \gets \mathsf{TxExt}(\mathsf{tx})$: The transaction extraction algorithm
extracts the set of universe accounts $\mathsf{AC}_T = \{\mathsf{ac}_i\}_{i \in T}$ encoded in the state $\mathsf{st}$.
\item $b \gets \mathsf{SrcChk}(\mathsf{ac,r,ssk,tsk,rsk,accd,clock})$: The source checking algorithm outputs a bit $b$ deciding whether to accept or reject that the account $\mathsf{ac}$ is associated to the provided secret keys and that $\mathsf{accd}$ has been commited with randomness $r$. If the account is commit based, it checks validity of $\mathsf{ssk,tsk}$ when $\mathsf{clock} <= \mathsf{time}$ and of $\mathsf{rsk}$ otherwise; if the account is standard only $\mathsf{ssk}$ is required.
\item $b \gets \mathsf{TgtChk}(\mathsf{ac,accd})$: The target checking algorithms outputs a bit $b$ deciding whether to accept or reject that the $\mathsf{accd}$ has been commited in $\mathsf{ac}$. 
\end{itemize}


\subsection*{Construction}

\begin{equation*}
\mathcal{R}(\mathsf{stmnt}, \mathsf{wit}) := \begin{cases} 
    S \subseteq R \\ 
    \xi_{\phi S(i)} = \Delta.\mathsf{Eval}(s_i) \qquad \forall i \in S \\
    \mathsf{SrcChk}(\mathsf{ac}_i, r, \mathsf{ssk}_i, \mathsf{tsk}_i, \mathsf{rsk}_i, \mathsf{accd}_i, \mathsf{clock}) = 1 \qquad \forall i \in S \\ 
    \mathsf{TgtChk}(\mathsf{ac'}_i, \mathsf{accd}'_i) = 1 \qquad \forall i \in T \\ 
    P(a_S, a'_T) = 1
\end{cases}
\end{equation*}

where 
\begin{equation*}
\mathsf{stmnt} := (P,\mathsf{AC}_R,\mathcal{Z}_{\bar{S}}, \mathsf{AC}_T, \mathsf{clock}) \\
\end{equation*}
\begin{equation*}
\mathsf{wit} := ((r,\mathsf{ssk}_i, \mathsf{tsk}_i, \mathsf{rsk}_i, \mathsf{accd}_i\}_{i\in S}), (\mathsf{smpk}_i, \mathsf{tmpk}_i, \mathsf{rmpk}_i, \mathsf{accd}'_i)_{i\in T}) \\
\end{equation*}



\begin{figure}
\begin{minipage}[t]{\textwidth}
\begin{pchstack}[boxed]

\begin{pcvstack}
\pseudocode{
    \mathsf{Setup}(1^\lambda) \\ [0.1\baselineskip ][\hline]
    \mathsf{crs} \gets \Pi.\mathsf{Setup}(1^\lambda) \\
    \mathsf{ck} \gets \Gamma.\mathsf{Gen}(1^\lambda) \\
    \mathsf{pp_\Delta} \gets \Delta.\mathsf{Setup}(1^\lambda) \\
    \mathbf{return} \: (\mathsf{pp}, \mathsf{st})
}
\vspace{1em}
\pseudocode{
    \mathsf{KGen}(\mathsf{pp}) \\[0.1\baselineskip ][\hline]
    \mathsf{msk} \sample\mathcal{K} \\
    \mathsf{mpk} := \Delta.\mathsf{KGen(msk)} \\
    \mathbf{return} \: (\mathsf{mpk}, \mathsf{msk})
}
\vspace{1em}
\pseudocode{
    \mathsf{Vf}(\mathsf{st},\mathsf{tx}) \\[0.1\baselineskip ][\hline]
    (\mathsf{AC}_U, \mathcal{Z}_U) := \mathbf{parse} \: \mathsf{st} \\
    \{\mathsf{ac}_i\}_{i \in U} := \mathbf{parse} \: \mathsf{AC}_U \\
    (P,R,\mathsf{AC}_T, \mathcal{Z}_{\bar{S}}) := \mathbf{parse} \: \mathsf{tx} \\
    \mathsf{AC}_R := \{\mathsf{ac}_i\}_{i \in R} \\
    \mathsf{stmnt} := (P,\mathsf{AC}_R,\mathsf{AC}_T,\mathcal{Z}_{\bar{S}}, \mathsf{clock}) \\
    \mathbf{if} \: \begin{cases}
        P \in \mathcal{P} \tabularnewline
        R \subseteq U \tabularnewline
        \Pi.\mathsf{Vf}(\mathsf{crs}, \mathsf{stmnt}, \pi) = 1 \tabularnewline
        \mathcal{Z}_{\bar{S}} \cap \mathcal{Z}_{\bar{U}} =  
    \end{cases} \: \mathbf{then} \\
    \:\: \mathbf{return} \: (1, \mathsf{st}') \\
    \mathbf{else} \: \mathbf{return} \: (0, \mathsf{st})
}
\vspace{1em}
\pseudocode{
    \mathsf{StExt}(\mathsf{st}) \\[0.1\baselineskip ][\hline]
    (\mathsf{AC}_U, \mathcal{Z}_U) := \mathbf{parse} \: \mathsf{st} \\
    \mathbf{return} \: \mathsf{AC}_U
}
\vspace{1em}
\pseudocode{
    \mathsf{TxExt}(\mathsf{tx}) \\[0.1\baselineskip ][\hline]
    (P,R,\mathsf{AC}_T, \mathcal{Z}_{\bar{S}}) := \mathbf{parse} \: \mathsf{tx} \\
    \mathbf{return} \: \mathsf{AC}_T
}
\vspace{1em}
\pseudocode{
    \mathsf{TgtChk}(\mathsf{ac}, \mathsf{accd}) \\[0.1\baselineskip ][\hline]
    \mathsf{co} := \mathbf{parse} \: \mathsf{ac} \\
    (r, \mathsf{accd}') := \mathbf{parse} \: \mathsf{tk} \\
    \mathbf{return} \: \begin{cases}
        \mathsf{accd}' = \mathsf{accd} \tabularnewline
        \mathsf{co} = \Gamma.\mathsf{Com}(\mathsf{accd},r)
    \end{cases} 
}
\end{pcvstack}
\qquad
\begin{pcvstack}
\pseudocode{
    \mathsf{KDer}(\mathsf{msk},\tau) \\[0.1\baselineskip ][\hline]
    (r, \delta, \mathsf{accd} := (a, \mathsf{time})) := \mathbf{parse} \: \tau \\
    \mathsf{sk} := \mathsf{msk}+\delta \\
    \mathbf{return} \: (\mathsf{sk}, r, \mathsf{accd})
}
\vspace{1em}
\pseudocode{
    \mathsf{TxGen}(\mathsf{st}, P, R, \mathcal{S}, \mathcal{T}) \\[0.1\baselineskip ][\hline]
    \{\mathsf{ssk}_i, \mathsf{tsk}_i, \mathsf{rsk}_i, \mathsf{accd}_i\}_{i\in S} := \mathbf{parse} \: \mathcal{S} \\
    \{\mathsf{smpk}_i, \mathsf{tmpk}_i, \mathsf{rmpk}_i, \mathsf{accd}'_i\}_{i\in T} := \mathbf{parse} \: \mathcal{T} \\
    \mathbf{for} \; i \in T \: \mathbf{do} \\
    \:\: r'_i \sample \chi \\
    \:\: \delta'_i \sample \mathcal{K} \\
    \:\: \mathsf{co}'_i := \Gamma.\mathsf{Com}(\mathsf{accd}'_i, r'_i) \\
    \:\: \mathsf{spk}'_i := \mathsf{smpk}_i + \Delta.\mathsf{Eval}(\delta''_i) \\
    \:\: \mathbf{if} \: \mathsf{rmpk}_i \neq \: \perp \land \: \mathsf{tmpk}_i \neq \: \perp \\
    \:\:\:\: \delta''_i \sample \mathcal{K} \\
    \:\:\:\: \delta'''_i \sample \mathcal{K} \\
    \:\:\:\: \mathsf{tpk}'_i := \mathsf{tmpk}_i + \Delta.\mathsf{Eval}(\delta'_i) \\
    \:\:\:\: \mathsf{rpk}'_i := \mathsf{rmpk}_i + \Delta.\mathsf{Eval}(\delta''_i) \\
    \;\:\:\: \mathsf{ac}'_i := (\mathsf{spk}'_i, \mathsf{tpk}'_i, \mathsf{rpk}'_i, \mathsf{co}'_i) \\
    \:\:\;\: \mathsf{tk}_i := (r'_i, \delta'_i, \delta''_i, \delta'''_i, \mathsf{accd}'_i) \\
    \;\: \mathbf{else} \\
    \;\:\:\: \mathsf{ac}'_i := (\mathsf{spk}'_i, \mathsf{co}'_i) \\
    \:\:\;\: \mathsf{tk}_i := (r'_i, \delta'_i, \mathsf{accd}'_i) \\
    \{\mathsf{ac}_i\}_{i \in U} := \mathsf{StExt(st)} \\
    \mathsf{AC}_R := \{\mathsf{ac}_i\}_{i \in R} \\
    \mathsf{AC}_T := \{\mathsf{ac}_i\}_{i \in T} \\
    \mathcal{Z}_{\bar{S}} := \{\Delta.\mathsf{Eval}(s_i)\}_{\phi S(i)\in \bar{S}} \\
    \mathsf{stmnt} := (P,\mathsf{AC}_R,\mathsf{AC}_T,\mathcal{Z}_{\bar{S}}, \mathsf{clock}) \\
    \mathsf{wit} := ((r,\mathsf{ssk}_i, \mathsf{tsk}_i, \mathsf{rsk}_i, \mathsf{accd}_i\}_{i\in S}), (\mathsf{smpk}_i, \mathsf{tmpk}_i, \mathsf{rmpk}_i, \mathsf{accd}'_i)_{i\in T}) \\
    \pi \gets \Pi.\mathsf{Prove}(\mathsf{crs},\mathsf{stmnt},\mathsf{wit}) \\
    \mathsf{tx} := (P,\mathsf{AC}_R,\mathsf{AC}_T,\mathcal{Z}_{\bar{S}}, \pi) \\
    \mathsf{TK} := {\mathsf{tk}_i}_{i \in T} \\
    \mathbf{return} \: (\mathsf{tx}, \mathsf{TK})
}
\vspace{1em}
\pseudocode{
    \mathsf{SrcChk}(\mathsf{ac}, r, \mathsf{ssk}, \mathsf{tsk}, \mathsf{rsk}, \mathsf{accd}, \mathsf{clock}) \\[0.1\baselineskip ][\hline]
    (\mathsf{tpk}, \mathsf{spk}, \mathsf{rpk}, \mathsf{co}) := \mathbf{parse} \: \mathsf{ac} \\
    \mathsf{time} := \mathbf{parse} \: \mathsf{accd} \\
    \mathbf{if} \: \mathsf{co} \neq \Gamma.\mathsf{Com}(\mathsf{accd}, r) \\
    \:\: \mathbf{return} \: 0 \\
    \mathbf{if} \: \mathsf{time} == \: \perp \\
    \:\: \mathbf{return} \: \mathsf{spk} = \Delta.\mathsf{KGen}(\mathsf{ssk}) \\
    \mathbf{else} \: \mathbf{if} \: \mathsf{time} <= \mathsf{clock} \\
    \:\: \mathbf{return} \: \begin{cases}
        \mathsf{tpk} = \Delta.\mathsf{KGen}(\mathsf{tsk}) \tabularnewline
        \mathsf{spk} = \Delta.\mathsf{KGen}(\mathsf{ssk}) \tabularnewline
    \end{cases} \\
    \mathbf{else} \\
    \:\: \mathbf{return} \: \mathsf{rpk} = \Delta.\mathsf{KGen}(\mathsf{rsk}) \\
}
\end{pcvstack}
\end{pchstack}
\end{minipage}%
\end{figure}


\end{document}
