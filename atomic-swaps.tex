\documentclass{article}      	% Style of the document                     
\usepackage{fullpage}
\usepackage{amsmath}     	   	% Maths                                          
\usepackage[utf8]{inputenc}	% UTF-8 characters                                               
\usepackage[T1]{fontenc}    	% Tuki ääkkösille (Finnish names don't cause problems)                                            
\usepackage{parskip}        		% Linebreak between paragraphs                
\usepackage{graphicx}       		% Graphics package for adding figures                        
\usepackage{epstopdf}       		% Possibility to add *.eps figures
 \usepackage{ dsfont }            % Symbol for real numbers
\usepackage{hyperref}
\usepackage{extarrows}
\usepackage{float}
\usepackage{enumitem}        % possibility to label list items by alphabet
\newcommand{\M}[1]{\ensuremath{\text{\texttt{#1}}}}
\usepackage[
    lambda,
    operators,
    advantage,
    sets,
    adversary,
    landau,
    probability,
    notions,
    logic,
    ff,
    mm,
    primitives,
    events,
    complexity,
    asymptotics,
    keys]{cryptocode}


 \usepackage{amsmath,amsfonts,graphicx,amssymb,amsthm}
\mathchardef\mhyphen="2D

 %% general
\mathchardef\mhyphen="2D
\newcommand{\fdv}{\mathcal{F}}
\newcommand{\tdv}{\mathcal{T}}
\newcommand{\vdv}{\mathcal{V}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\ID}{\mathcal{I}}
\newcommand{\bits}[1][]{\{0,1\}^{#1}}
\renewcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\mat}[1]{\mathbf{#1}}
\newcommand{\inner}[2]{\langle #1, #2 \rangle}
\newcommand{\transpose}{\mathtt{T}}
\newcommand{\round}[1]{\lfloor #1 \rceil}
\renewcommand{\dist}{\mathsf{dist}}
\renewcommand{\Pr}[2][]{{\text{Pr}_{#1}\left[#2\right]}}
\newcommand{\Exp}[2][]{{\mathbb{E}_{#1}\left[#2\right]}}
\newcommand{\mathcm}[2][1cm]{\hspace{#1}{\mbox{/\!\!/ } \text{\scriptsize#2}}}

%% lattice problems
\newcommand{\SIS}{\mathsf{SIS}}
\newcommand{\ISIS}{\mathsf{ISIS}}
\newcommand{\nfSIS}{\mathsf{nfSIS}}
\newcommand{\dSIS}{\mathsf{dSIS}}
\newcommand{\LWE}{\mathsf{LWE}}
\newcommand{\nfLWE}{\mathsf{nfLWE}}
\newcommand{\nfdLWE}{\mathsf{nfdLWE}}
\newcommand{\sLWE}{\mathsf{sLWE}}
\newcommand{\dLWE}{\mathsf{dLWE}}
\newcommand{\SVP}{\mathsf{SVP}}
\newcommand{\CVP}{\mathsf{CVP}}
\newcommand{\SIVP}{\mathsf{SIVP}}
\newcommand{\GapSVP}{\mathsf{GapSVP}}
\newcommand{\BDD}{\mathsf{BDD}}
\newcommand{\NTRU}{\mathsf{NTRU}}
\newcommand{\sNTRU}{\mathsf{sNTRU}}
\newcommand{\dNTRU}{\mathsf{dNTRU}}

%% lattice macros
\newcommand{\TT}{\mathbb{T}}
\newcommand{\ring}{\mathcal{R}}
\newcommand{\lattice}{\mathcal{L}}
\newcommand{\piped}{\mathcal{P}}
\newcommand{\ball}{\mathcal{B}}
\newcommand{\Hyb}{\mathsf{Hyb}}
\newcommand{\lspan}{\mathsf{span}}
\newcommand{\rank}{\mathsf{rank}}
\newcommand{\lsb}{\mathsf{LSB}}
\newcommand{\pubparam}{\mathsf{pp}}

%% group macros

%% syntax
\newcommand{\mpk}{\mathsf{mpk}}
\newcommand{\msk}{\mathsf{msk}}
\newcommand{\msg}{\mathsf{msg}}
\newcommand{\rnd}{\mathsf{rnd}}
\newcommand{\ctxt}{\mathsf{ctxt}}
\newcommand{\com}{\mathsf{com}}
\newcommand{\td}{\mathsf{td}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\stmt}{\mathsf{stmt}}
\newcommand{\wit}{\mathsf{wit}}
\newcommand{\tx}{\mathsf{tx}}
\newcommand{\aux}{\mathsf{aux}}
\newcommand{\ek}{\mathsf{ek}}

\newcommand{\Setup}{\mathsf{Setup}}
\newcommand{\Commit}{\mathsf{Com}}
\newcommand{\TrapGen}{\mathsf{TrapGen}}
\newcommand{\SampD}{\mathsf{SampD}}
\newcommand{\SampPre}{\mathsf{SampPre}}
\newcommand{\Prove}{\mathsf{Prove}}
\newcommand{\Verify}{\mathsf{Verify}}
\newcommand{\val}{\mathsf{val}}

%% primitive/scheme name
\newcommand{\PKE}{\mathsf{PKE}}
\newcommand{\LTDF}{\mathsf{LTDF}}
\newcommand{\rsagen}{\mathsf{RSAGen}}
\newcommand{\rsa}{\mathsf{RSA}}
\newcommand{\LHE}{\mathsf{LHE}}
\newcommand{\CS}{\mathcal{CS}}
\newcommand{\NTRUEncrypt}{\mathsf{NTRUEncrypt}}

%% others
\newcommand{\oracle}{\mathcal{O}}
\newcommand{\pcas}{~\mathbf{as}~}

\newcommand{\polylog}[1][\secpar]{\mathsf{polylog}(#1)}

\newcommand{\indrsidcpa}{\mathrm{IND\$}\mhyphen\mathrm{sID}\mhyphen\mathrm{CPA}}
%\newcommand{\oplus}{\, \texttt{XOR} \,} % shorthand for typing the XOR operator in mathmode

% feel free to add packages you need
% feel free to add packages you need

\begin{document}         
\author{Lorenzo Tucci}
\title{Atomic swaps}

\maketitle

Parties $U_0$ and $U_1$ hold assets $a$ on blockchain $\mathbb{A}$ and assets $b$ on chain $\mathbb{B}$ respectively. \\
We define with $\mathsf{swp}(a)$ and $\mathsf{swp}(b)$ the amount of the assets the parties agreed to swap before starting the protocol. \\

We define the following oracles to interact with the blockchains.

- $\mathsf{PubTx}(\sigma_{tx}, tx, \mathbb{A})$ publish the transaction $tx$ with signature $\sigma_{tx}$ on chain $\mathbb{A}$ \\
- $\mathsf{InitTx}(pk_{tx}, pk_{rx}, amnt, \mathbb{A})$ create an unsigned transaction paying $amnt$ from $pk_{tx}$ to $pk_{rx}$ on chain $\mathbb{A}$ \\
- $\mathsf{WatchTx}(tx, \mathbb{A})$ wait for the transaction $tx$ to be confirmed on chain $\mathbb{A}$ \\
- $\mathsf{GetBal}(pk, \mathbb{A})$ get the balance of assets held by $pk$ \\
- $\mathsf{GetSig}(pk, \mathbb{A})$ get the signature $\sigma_{tx}$ of the latest transaction in $pk$'s record on chain $\mathbb{A}$ \\

$U_1$ starts counting the timeout from the moment they send the $\mathsf{VTD}$ commitment to $U_0$, and respectively $U_0$ starts counting down from the moment they receive it. \\
\\
If the timeout expires before the protocol is completed: 
\begin{itemize}
    \item $U_1$ will transfer the coins from $pk(1)$ to another wallet on $\mathbb{B}$. From this moment on, if $U_0$ tries to $\mathsf{PubTx}(\sigma_{\mathsf{swp(10)}}, tx_\mathsf{swp}, \mathbb{A})$, the transaction will get rejected. \\
    \item $U_0$ will wait until $\Pi_{\mathsf{VTD}}.\mathsf{ForceOp}(C)$ is completed to get the other secret key share $sk_1(01)$ of $pk(10)$ to retrieve $sk(10)$ and transfer back assets $a$ to $pk(0)$.
\end{itemize}

\begin{figure}[H]
\begin{pchstack}[center, boxed]
\pseudocode{
    \textbf{$U_0(pk(0)\:, sk(0)$)} \< \< \textbf{$U_1(pk(1)\:, sk(1))$} \\[0.1\baselineskip ][\hline] 
    \<\< \\[-0.5\baselineskip ]
    \< \sendmessage*{<->}{top={{\Gamma_{\mathsf{KeyGen}}(\mathbb{G},G,q)}}, bottom={\xlongleftarrow{} (sk_0(01), pk(01)) \\ (sk_1(01), pk(01)) \xlongrightarrow{} }} \< \\
    \<\< (C, \pi) \gets \Pi_{\mathsf{VTD}}.\mathsf{Commit}(sk_1, T) \\
    \< \sendmessageleft*{(C, \pi)} \< \\
    \mathsf{starts}\: \mathsf{Timeout}(T - \Delta)
    \<\< \mathsf{starts}\: \mathsf{Timeout}(T - \Delta) \\
    \mathsf{if}\: \Pi_{\mathsf{VTD}}.\mathsf{Verify}(pk, C, \pi) \neq 1 \\
    \qquad \mathsf{abort}\\
    tx_\mathsf{frz} \gets \mathsf{InitTx}(pk(0), pk(01), \mathsf{swp(a)}, \mathbb{A}) \\
    \sigma_{\mathsf{frz}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}(sk(0), tx_\mathsf{frz}) \\
    \mathsf{PubTx}(\sigma_{\mathsf{frz}}, tx_\mathsf{frz}, \mathbb{A}) \\
    \mathsf{starts}\: \Pi_{\mathsf{VTD}}.\mathsf{ForceOp}(C) \\
    \<\< \mathsf{do}\: \mathsf{bal} \gets \mathsf{GetBal}(pk(01), \mathbb{A}) \\
    \<\< \mathsf{while}\: \mathsf{bal} \neq \mathsf{swp(a)}\\
    \< \sendmessageleft*{pk(1)} \< \\
    (pk(10), sk(10)) \gets \Pi_{\mathsf{DS}}.\mathsf{KeyGen}(1^\lambda) \\
    tx_\mathsf{swp} \gets \mathsf{InitTx}(pk(1), pk(10), \mathsf{swp(b)}, \mathbb{A}) \\
    \< \sendmessage*{<->}{top={{\Gamma_{\mathsf{Swap}} \qquad \qquad \\ U_0 \xlongrightarrow{} (sk_0(01), tx_\mathsf{swp}) \\ (sk_1(01), sk(1)) \xlongleftarrow{} U_1 }}, bottom={lk := \sigma_{swp}(10) \oplus sk_0(01) \xlongrightarrow{} \\  \xlongleftarrow{} \sigma_{swp}(10) \qquad \qquad  }} \< \\
    \mathsf{PubTx}(\sigma_{\mathsf{swp(10)}}, tx_\mathsf{frz}, \mathbb{A}) \\
    \<\< \mathsf{do}\: \sigma_{swp}(10) \gets \mathsf{GetSig}(pk(1), \mathbb{B}) \\
    \<\< \qquad sk(01) \gets (lk \oplus \sigma_{swp}(10)) \oplus sk_1 \\
    \<\< \qquad \sigma_{m} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}(sk(01), 1) \\
    \<\< \mathsf{while}\: \Pi_{\mathsf{DS}}.\mathsf{Verify}(m, pk, \sigma_{m}) \neq 1 \\
}
\end{pchstack}
\caption{Protocol execution for a successful swap}
\end{figure}

\begin{figure}[H]
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (\mathbb{G}, G, q, T, \mathsf{swp}(a), \mathsf{swp}(b),\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    (sk_0(01), pk(01)) \gets \mathsf{\textbf{wait}} \:\: \Gamma_{\mathsf{KeyGen}}(\mathbb{G}, G, q) \\
    (C, \pi) \gets \mathsf{\textbf{wait}} \:\: \mathsf{receive}(U_1) \\
    \mathsf{\textbf{if}} \:\: \Pi_{\mathsf{VTD}}.\mathsf{Verify}(pk, C, \pi) \neq 1 \\
    \quad \mathsf{\textbf{return}} \perp \\
    \mathsf{res} \gets \mathsf{\textbf{select}} \:\: \{ \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \Pi_{\mathsf{VTD}}.\mathsf{ForceOp}(C) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad  (pk(10), sk(10)) \gets \Pi_{\mathsf{DS}}.\mathsf{KeyGen}(1^\lambda) \\
    \qquad tx_\mathsf{frz} \gets \mathsf{\textbf{wait}} \:\: \mathsf{InitTx}(pk(0), pk(01), \mathsf{swp(a)}, \mathbb{A}) \\
    \qquad \sigma_{\mathsf{frz}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}(sk(0), tx_\mathsf{frz}) \\
    \qquad \mathsf{\textbf{wait}} \:\: \mathsf{PubTx}(\sigma_{\mathsf{frz}}, tx_\mathsf{frz}, \mathbb{A}) \\
    \qquad pk(1) \gets \mathsf{\textbf{wait}} \:\: \mathsf{receive}(U_1) \\
    \qquad tx_\mathsf{swp} \gets \mathsf{\textbf{wait}} \:\: \mathsf{InitTx}(pk(1), pk(10), \mathsf{swp(b)}, \mathbb{B}) \\
    \qquad \sigma_{swp}(10) \gets \mathsf{\textbf{wait}} \:\: \Gamma_{\mathsf{Swap}}(sk_0(01), tx_{swp}) \\
    \qquad \mathsf{\textbf{wait}} \:\: \mathsf{PubTx}(\sigma_{\mathsf{swp}(10)}, tx_{swp}, \mathbb{B}) \\
    \quad \} \\
    \} \\
    \mathsf{\textbf{if}} \:\: \mathsf{res} \neq 1 \\
    \quad sk(01) := sk_0(01) \oplus \mathsf{res} \\
    \quad tx_\mathsf{rfnd} \gets \mathsf{\textbf{wait}} \:\: \mathsf{InitTx}(pk(01), pk(0), \mathsf{swp(a)}, \mathbb{A}) \\
    \quad \sigma_{\mathsf{rfnd}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}(sk(01), tx_\mathsf{rfnd}) \\
    \quad \mathsf{\textbf{wait}} \:\: \mathsf{PubTx}(\sigma_{\mathsf{rfnd}}, tx_{rfnd}, \mathbb{A}) \\
}
\end{pchstack}
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (\mathbb{G}, G, q, T, \mathsf{swp}(a), \mathsf{swp}(b),\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    (sk_1(01), pk(01)) \gets \mathsf{\textbf{wait}} \:\: \Gamma_{\mathsf{KeyGen}}(\mathbb{G}, G, q) \\
    (C, \pi) \gets \Pi_{\mathsf{VTD}}.\mathsf{Commit}(sk_1, T) \\
    \mathsf{send}(U_1,\: (C, \pi)) \\
    \mathsf{res} \gets \mathsf{\textbf{select}} \:\: \{ \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{timeout}(T/2) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{\textbf{do}} \:\: \mathsf{bal} \gets \mathsf{\textbf{wait}} \:\: \mathsf{GetBal}(pk(01), \mathbb{A}) \\
    \qquad \mathsf{\textbf{while}} \:\: \mathsf{bal} \neq {\mathsf{swp}(a)} \\
    \qquad \mathsf{send}(U_1,\: \pk(1)) \\
    \qquad \sigma_{swp}(10) \gets \mathsf{\textbf{wait}} \:\: \Gamma_{\mathsf{Swap}}(sk_1(01), sk(1)) \\
    \qquad \mathsf{\textbf{do}} \:\: \mathsf{\sigma_{swp}(10)} \gets \mathsf{\textbf{wait}} \:\: \mathsf{GetSig}(pk(1), \mathbb{B}) \\
    \qquad \quad sk(01) \gets (lk \oplus \sigma_{swp}(10)) \oplus sk_1 \\
    \qquad \quad \sigma_{b} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}(sk(01), 1) \\
    \qquad \mathsf{\textbf{while}} \:\: \Pi_{\mathsf{DS}}.\mathsf{Verify}(m, pk, \sigma_{b}) \neq 1 \\
    \qquad tx_\mathsf{swp} \gets \mathsf{\textbf{wait}} \:\: \mathsf{InitTx}(pk(01), pk_{\mathbb{A}}(1), \mathsf{swp(a)}, \mathbb{A}) \\
    \qquad \sigma_{\mathsf{swp}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}(sk(01), tx_\mathsf{rfnd}) \\
    \qquad \mathsf{\textbf{wait}} \:\: \mathsf{PubTx}(\sigma_{\mathsf{swp}}, tx_{swp}, \mathbb{A}) \\
    \quad \} \\
    \} \\
    \mathsf{\textbf{if}} \:\: \mathsf{res} \neq 1 \\
    \quad  (pk(11), sk(11)) \gets \Pi_{\mathsf{DS}}.\mathsf{KeyGen}(1^\lambda) \\
    \quad tx_\mathsf{rfnd} \gets \mathsf{\textbf{wait}} \:\: \mathsf{InitTx}(pk(1), pk(11), \mathsf{swp(b)}, \mathbb{B}) \\
    \quad \sigma_{\mathsf{rfnd}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}(sk(1), tx_\mathsf{rfnd}) \\
    \quad \mathsf{\textbf{wait}} \:\: \mathsf{PubTx}(\sigma_{\mathsf{rfnd}}, tx_\mathsf{rfnd}, \mathbb{B}) \\
}
\end{pchstack}

\end{minipage}%
\caption{Full protocol execution for $U_0$ and $U_1$, respectively left and right (alternative syntax)}
\end{figure}




\begin{figure}[H]
\begin{pchstack}[center, boxed]

\pseudocode{
    \textbf{$U_0(pk(0)\:, sk(0)$)} \< \< \textbf{$U_1(pk(1)\:, sk(1))$} \\[0.1\baselineskip ][\hline] 
    \<\< \\[-0.5\baselineskip ]
    sk(01) := sk_0(01) \oplus sk_1(01) \\
    \sigma_{swp}(10) \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}(sk(1), tx_\mathsf{swp}) \\
    lk := \sigma_{swp}(10) \oplus sk_0(01) \\
}
\end{pchstack}
\caption{Protocol definition of 2PC $\Gamma_{\mathsf{Swap}}$}
\end{figure}




\end{document}
