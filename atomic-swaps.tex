\documentclass{article}      	% Style of the document                     
\usepackage{fullpage}
\usepackage{amsmath,amsthm}     	   	% Maths    
\newtheorem{definition}{Definition}                                      
\usepackage[utf8]{inputenc}	% UTF-8 characters                                               
\usepackage[T1]{fontenc}    	% Tuki ääkkösille (Finnish names don't cause problems)                                            
\usepackage{parskip}        		% Linebreak between paragraphs                
\usepackage{svg}
\usepackage{graphicx}       		% Graphics package for adding figures                        
\usepackage{epstopdf}       		% Possibility to add *.eps figures
 \usepackage{ dsfont }            % Symbol for real numbers
\usepackage{extarrows}
\usepackage{float}
\usepackage{makeidx}
\usepackage{enumitem}        % possibility to label list items by alphabet
\usepackage[a4paper, top=0.5in]{geometry}
\newcommand{\M}[1]{\ensuremath{\text{\texttt{#1}}}}
\usepackage[
    lambda,
    operators,
    advantage,
    sets,
    adversary,
    landau,
    probability,
    notions,
    logic,
    ff,
    mm,
    primitives,
    events,
    complexity,
    asymptotics,
    keys]{cryptocode}

\usepackage{todonotes}
\usepackage{tcolorbox}

 \usepackage{amsmath,amsfonts,graphicx,amssymb,amsthm}


\usepackage[bookmarksdepth=2,draft=false]{hyperref}
\hypersetup{colorlinks=true,linkcolor={red!50!black},citecolor=darkgray,linkcolor=darkgray}
\usepackage[capitalize]{cleveref}

\mathchardef\mhyphen="2D

 %% general
\mathchardef\mhyphen="2D
\newcommand{\fdv}{\mathcal{F}}
\newcommand{\tdv}{\mathcal{T}}
\newcommand{\vdv}{\mathcal{V}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\ID}{\mathcal{I}}
\newcommand{\bits}[1][]{\{0,1\}^{#1}}
\renewcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\mat}[1]{\mathbf{#1}}
\newcommand{\inner}[2]{\langle #1, #2 \rangle}
\newcommand{\transpose}{\mathtt{T}}
\newcommand{\round}[1]{\lfloor #1 \rceil}
\renewcommand{\dist}{\mathsf{dist}}
\renewcommand{\Pr}[2][]{{\text{Pr}_{#1}\left[#2\right]}}
\newcommand{\Exp}[2][]{{\mathbb{E}_{#1}\left[#2\right]}}
\newcommand{\mathcm}[2][1cm]{\hspace{#1}{\mbox{/\!\!/ } \text{\scriptsize#2}}}

%% lattice problems
\newcommand{\SIS}{\mathsf{SIS}}
\newcommand{\ISIS}{\mathsf{ISIS}}
\newcommand{\nfSIS}{\mathsf{nfSIS}}
\newcommand{\dSIS}{\mathsf{dSIS}}
\newcommand{\LWE}{\mathsf{LWE}}
\newcommand{\nfLWE}{\mathsf{nfLWE}}
\newcommand{\nfdLWE}{\mathsf{nfdLWE}}
\newcommand{\sLWE}{\mathsf{sLWE}}
\newcommand{\dLWE}{\mathsf{dLWE}}
\newcommand{\SVP}{\mathsf{SVP}}
\newcommand{\CVP}{\mathsf{CVP}}
\newcommand{\SIVP}{\mathsf{SIVP}}
\newcommand{\GapSVP}{\mathsf{GapSVP}}
\newcommand{\BDD}{\mathsf{BDD}}
\newcommand{\NTRU}{\mathsf{NTRU}}
\newcommand{\sNTRU}{\mathsf{sNTRU}}
\newcommand{\dNTRU}{\mathsf{dNTRU}}

%% lattice macros
\newcommand{\TT}{\mathbb{T}}
\newcommand{\ring}{\mathcal{R}}
\newcommand{\lattice}{\mathcal{L}}
\newcommand{\piped}{\mathcal{P}}
\newcommand{\ball}{\mathcal{B}}
\newcommand{\Hyb}{\mathsf{Hyb}}
\newcommand{\lspan}{\mathsf{span}}
\newcommand{\rank}{\mathsf{rank}}
\newcommand{\lsb}{\mathsf{LSB}}
\newcommand{\pubparam}{\mathsf{pp}}

%% group macros

%% syntax
\newcommand{\mpk}{\mathsf{mpk}}
\newcommand{\msk}{\mathsf{msk}}
\newcommand{\msg}{\mathsf{msg}}
\newcommand{\rnd}{\mathsf{rnd}}
\newcommand{\ctxt}{\mathsf{ctxt}}
\newcommand{\com}{\mathsf{com}}
\newcommand{\td}{\mathsf{td}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\stmt}{\mathsf{stmt}}
\newcommand{\wit}{\mathsf{wit}}
\newcommand{\tx}{\mathsf{tx}}
\newcommand{\aux}{\mathsf{aux}}
\newcommand{\ek}{\mathsf{ek}}

\newcommand{\Setup}{\mathsf{Setup}}
\newcommand{\Commit}{\mathsf{Com}}
\newcommand{\TrapGen}{\mathsf{TrapGen}}
\newcommand{\SampD}{\mathsf{SampD}}
\newcommand{\SampPre}{\mathsf{SampPre}}
\newcommand{\Prove}{\mathsf{Prove}}
\newcommand{\Verify}{\mathsf{Verify}}
\newcommand{\val}{\mathsf{val}}

%% primitive/scheme name
\newcommand{\PKE}{\mathsf{PKE}}
\newcommand{\LTDF}{\mathsf{LTDF}}
\newcommand{\rsagen}{\mathsf{RSAGen}}
\newcommand{\rsa}{\mathsf{RSA}}
\newcommand{\LHE}{\mathsf{LHE}}
\newcommand{\C}{\mathcal{CS}}
\newcommand{\NTRUEncrypt}{\mathsf{NTRUEncrypt}}

%% others
\newcommand{\oracle}{\mathcal{O}}
\newcommand{\pcas}{~\mathbf{as}~}

\newcommand{\polylog}[1][\secpar]{\mathsf{polylog}(#1)}

\newcommand{\indrsidcpa}{\mathrm{IND\$}\mhyphen\mathrm{sID}\mhyphen\mathrm{CPA}}
%\newcommand{\oplus}{\, \texttt{XOR} \,} % shorthand for typing the XOR operator in mathmode
\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}


\definecolor{cgreen}{RGB}{0, 153, 51}
\definecolor{cblue}{RGB}{0, 102, 204}
\definecolor{cyellow}{RGB}{255, 204, 0} 
\definecolor{cred}{RGB}{204, 51, 0} 

\newtcolorbox{todobox}{colback=yellow!3!white, colframe=white!75!black, title=Overview}

\newcommand{\commentline}[2]{%
    \tikz[remember picture, overlay]{
        \node [black,anchor=west,xshift=10pt] at (#1) {#2};
    }
}

\newcommand{\blockcomment}[3]{%
    \tikz[remember picture, overlay]{
        \draw [decorate,decoration={lineto,amplitude=10pt,mirror,raise=4pt},yshift=0pt,very thick,{#3}] 
        (#1) -- (#2) node [black,midway,xshift=10pt] {};
    }
}



\usepackage{biblatex}
\addbibresource{references.bib}

\begin{document}         
\author{Lorenzo Tucci}
\title{RingCCT: confidential commit transactions and atomic swaps}

\maketitle

\tableofcontents
\newpage

\section{Introduction}
\begin{todobox}
\textbf{Narrative}
\begin{itemize}
\item Universal atomic swaps allow atomic swaps across arbitrary pairs of chains which support ordinary transactions, in particular without requiring support of scripting, time-lock contracts, etc.
\item This is appealing because most privacy chains (e.g. ZCash, Monero, MimbleWimble) do not support scripting.
\item However, UAS requires both parties to solve TLPs, which are computationally intensive especially for lightweight clients.
\item Moreover, it is tricky from an implementation perspective to properly set the difficulty level TLPs in UAS. For example, we identify a minor flaw ... and propose a fix.
\end{itemize}

\textbf{Contributions}
\begin{itemize}
\item We identify that a minimal chain functionality -- commit transactions -- suffices for achieving atomic swaps. Concretely, we propose a generic construction of an atomic swap protocol using only commit transactions and other basic functionalities of the chains. (To avoid dealing with UC, maybe we write this as an informal theorem?)
\item We propose an extension of RingCT, the underlying transaction scheme of Monero, which allows to realise commit transactions in privacy-preserving cryptocurrencies. We propose a generic construction and show how to efficiently instantiate it over groups where discrete logarithm and other related problems are hard. 
\item We provide a prototype implementation of CommitTx-based atomic swaps
\end{itemize}

\textbf{Discussion}
\begin{itemize}
    \item Why chains might want to support commit transactions but not "hash time lock contracts (HTLC)"? 
    \item From UAS paper: Both chains need to support the same hash function for HTLC-based atomic swaps to work. 
    \item On the other hand, commit transactions is a "local" functionality. 
    \item HTLC implies commit transaction (?) (But then this will imply HTLC-based atomic swaps do not need to share the same hash function?)
    \item In our construction, CommitTx accounts are trivially distinguishable from ordinary accounts. We justify this design choice by arguing that it is impossible to achieve "cross-type account indistinguishability" without violating availability.
\end{itemize}
\textbf{TODO}
\begin{itemize}
    \item Find out what are already known/considered for commit transactions (or however it is called)
    \item Discuss "natural applications" of commit transactions, beyond atomic swaps, e.g. P2P escrow system 
    \item Find out what goes wrong if one tries to realise HTLC in privacy-preserving chains, e.g. Monero.
    \item A more detailed comparison between CommitTx-based and HTLC-based atomic swaps, and see how exactly does the former avoid needing both chains to share common configurations, e.g. the same hash function.
\end{itemize}
\end{todobox}

\subsection{HTLC comparison}

\subsubsection{Definition}
a Hash Time Lock Contract (HTLC) is defined by a tuple $(\mathsf{amnt_a}, h, T, \mathsf{pk_0}, \mathsf{pk_1})$ where 
\begin{itemize}
	\item $\mathsf{amnt_a}$ denotes the amount of $\mathsf{a}$ assets to be exchanged
	\item $h$ is a hash value
	\item $T$ the timeout
	\item $\mathsf{pk_{tx}}$ and $\mathsf{pk_{rx}}$ the public key addresses of two users
\end{itemize}

The HTLC transfers $\mathsf{amnt_a}$ to $\mathsf{pk_1}$ if invoked before timeout $T$ with input value $r$ such that $\mathcal{H}(r) = h$. 
If the contract is invoked after timeout $T$, it refunds the assets $\mathsf{amnt_a}$ to $\mathsf{pk_0}$ unconditionally.

Using HTLCs as a building block, an atomic swap protocol can be constructed as follows: \\
1) Alice chooses $r$, computes $h = \mathcal{H}(r)$, transfers $\mathsf{amnt_a}$ into an $(\mathsf{amnt_a}, h, T_0, \mathsf{pk_0}, \mathsf{pk_1})$ on blockchain $\mathbb{A}$ and sends $h,T$ to Bob. \\
2) Bob finishes the setup of the exchange by choosing a time $T_1 < T_0$ and transferring his $\mathsf{amnt_b}$ assets into an HTLC$(\mathsf{amnt_b}, h, T_1, \mathsf{pk_{tx}}, \mathsf{pk_{rx}})$ on blockchain $\mathbb{B}$.


\subsubsection{Comparison}
Clearly, HTLCs have the following drawbacks:
\begin{itemize}
	\item An HTLCs-based cross-chain protocol requires both chains to support the same hash function. (This could be avoided if the mover provides the hash-value $h'$ of $r$ supported by chain $\mathbb{B}$, together with a NIZK proving that $H(r) = h \land H'(r) = h'$ ; but complicates the protocol).
	\item The hash preimage is reused across different chains, creates a link between those payments, which is not privacy friendly. (Similarly to above we can give $H(r+r')$, and give $r'$ together with a proof that $H(r+r') = h' \land H(r) = h$).
	\item If naively implemented on RingCT, we make transaction easily distinguishable. If privately implemented, the protocol is asymmetric (public chain must always move first, in order to obtain preimage and mage of h).
	\item Straighforward private chain to private chain HTLCs might not be possible
	\item CommitTx, even for public chains, have no extra data on-chain except the timeout. Equivalent to a timeout-based multisig.
	\item Potential security issues (miner incentives) ? https://eprint.iacr.org/2022/546.pdf
\end{itemize}


\subsubsection{Commit Transaction interface}
\begin{itemize}[topsep=0pt, itemsep=0pt, leftmargin=2em]
	\item Commit phase: A user makes a transaction sending $a$ coins to an account which is a binding commitment to the amount $a$, a main secret key $\mathsf{sk}_0$, a list of auxiliary secret keys $\mathsf{sk}_1, \dots, \mathsf{sk}_k$, and two (or more) index sets $I_0, I_1 \subseteq [k]$.
	\item Reveal phase: Before time $T$, the main key $\mathsf{sk}_0$ and the auxiliary keys $(\mathsf{sk}_i)_{i \in I_0}$ are needed to spend from the account. After time $T$, the main key $\mathsf{sk}_0$ and the auxiliary keys $(\mathsf{sk}_i)_{i \in I_1}$ are needed to spend from the account. The tag of an account is deterministically computed from the main key $\mathsf{sk}_0$.
\end{itemize}
%$(\mathsf{hpk}, \mathsf{tx}) \gets \mathbf{CommitTx}(\mathsf{spk}, \mathsf{rpk}, \mathsf{tpk}, \mathsf{ssk}, \mathsf{amnt}, \mathsf{T})$: creates a commit account, paying $\mathsf{amnt}$ from  to $\mathsf{rpk}$ valid until time $\mathsf{T}$, whith  $\mathsf{amnt}$ being locked from being spent on transactions from $\mathsf{pk_{tx}}$ until $\mathsf{T}$. The transaction can be later finalized by opening and broadcasting $C$ through $\mathsf{RevTx}$.


\section{RingCCT: Ring confidential commit transaction}
We present an extension of ring confidential transactions (RingCT), called ring confidential commit transactions (RingCCT).

\subsection{Syntax}

A RingCCT scheme is initialised by running the algorithm $\mathsf{Setup}$ that generates the public parameters and initial state $\mathsf{st}$. The system can be joined by running $\mathsf{KGen}$ to generate master public key pair consisting of $\mathsf{mpk}$ and $\mathsf{msk}$.
Accounts in the systems are defined by the tuple $(\mathsf{spk}, \mathsf{tpk}, \mathsf{rpk}, \mathsf{rsk}, \mathsf{co})$, where 
\begin{itemize}
	\item $\mathsf{co}$ is a commitment of the account data $\mathsf{accd}$, which is a tuple of $(a, \mathsf{time})$. $a$ denotes the amount stored in the account, while $\mathsf{time}$ is an optional epoch timeout parameter that defines a cutoff epoch for the ownership of the commit account.
	\item $\mathsf{spk}$ is the public key of the owner of the account. In case $\mathsf{time}$ is defined as 0, this is the only owner of the account, as in normal RingCT.
	\item $\mathsf{tpk}$ is the public key of the joint owner of a commit transaction account, the ccommit account is jointly owned by $\mathsf{spk}, \mathsf{tpk}$ until the epoc defined $\mathsf{time}$.
	\item $\mathsf{rpk}$ is a recovery public key, which becomes the owner of a commit transaction account after $\mathsf{time}$.
\end{itemize}

\textbf{Definition} A RingCCT scheme (Ring Commit Confidential Transactions) scheme consists of the PPT algorithms ($\mathsf{Setup,KGen,Tx,Vf,StExt,TxExt,SrcChk,TgtChk}$) whose interfaces are defined as follows.

\begin{itemize}
    \item $(\mathsf{pp,st}) \gets \mathsf{Setup}(1^\lambda)$: the setup algorithm generates the public parameters $\mathsf{st}$ and an initial global state $\mathsf{st}$.
    \item $(\mathsf{mpk},\mathsf{msk}) \gets \mathsf{KGen}(\mathsf{pp})$: the key generation algorithm generates a master public key $\mathsf{mpk}$ and a matching secret key $\mathsf{msk}$.
    \item $(\mathsf{sk},\mathsf{accd}) \gets \mathsf{KDer}(\mathsf{msk, \tau})$: the key derivation algorithm generates derives the keys-account data tuple given the master key $\mathsf{msk}$ owning the account and the token $\tau$ of the account.
    \item $(\mathsf{tx,TK}) \gets \mathsf{TxGen}(\mathsf{st},P,R,\mathcal{S},\mathcal{T})$: the transaction algorithm inputs a state $\mathsf{st}$, a predicate $P: \mathbb{Z}^S \times \mathbb{Z}^T \rightarrow \{0,1\}$, an index set R called the ring, a set of source accouts information $\mathcal{S} = \{\mathsf{ssk}_i, \mathsf{tsk}_i, \mathsf{rsk}_i, \mathsf{accd}_i\}_{i\in S}$ and some targets account information $\mathcal{T} = \{\mathsf{smpk}_i, \mathsf{tmpk}_i, \mathsf{rmpk}_i, \mathsf{accd}'_i\}_{i\in T}$; where $\mathsf{ssk,tsk,rsk}$ and $\mathsf{spk,tpk,rpk}$ are the source, target and recovery secret and public keys respectively. If source or target account is not commit based, only the source key pair is defined. Each account has some $\mathsf{accd} := (a,\mathsf{time})$ defined, where $a$ represents some amount and $\mathsf{time}$ sets a specific epoch timeout of the ownership of commit account by the target key pair, and empty otherwise. 
    \item $(b,\mathsf{st}') \gets \mathsf{Vf}(\mathsf{st,tx})$: The verification algorithm outputs a bit b deciding whether to accept or reject that the transaction $\mathsf{tx}$ is a valid relative to the state $\mathsf{st}$, outputting an updated state $\mathsf{st}'$ if the verification is sucessful.
\item $\mathsf{AC}_U \gets \mathsf{StExt}(\mathsf{st})$: The state extraction algorithm
extracts the set of universe accounts $\mathsf{AC}_U = \{\mathsf{ac}_i\}_{i \in U}$ encoded in the state $\mathsf{st}$.
\item $\mathsf{AC}_T \gets \mathsf{TxExt}(\mathsf{tx})$: The transaction extraction algorithm
extracts the set of universe accounts $\mathsf{AC}_T = \{\mathsf{ac}_i\}_{i \in T}$ encoded in the state $\mathsf{st}$.
\item $b \gets \mathsf{SrcChk}(\mathsf{ac,r,ssk,tsk,rsk,accd,clock})$: The source checking algorithm outputs a bit $b$ deciding whether to accept or reject that the account $\mathsf{ac}$ is associated to the provided secret keys and that $\mathsf{accd}$ has been commited with randomness $r$. If the account is commit based, it checks validity of $\mathsf{ssk,tsk}$ when $\mathsf{clock} <= \mathsf{time}$ and of $\mathsf{rsk}$ otherwise; if the account is standard only $\mathsf{ssk}$ is required.
\item $b \gets \mathsf{TgtChk}(\mathsf{ac,accd})$: The target checking algorithms outputs a bit $b$ deciding whether to accept or reject that the $\mathsf{accd}$ has been commited in $\mathsf{ac}$. 
\end{itemize}

\subsection{Correctness}

\subsection{Security}
We here define the security properties of RingCCT.

\begin{definition}[Balance] A RingCCT scheme is balanced if: \\
	1. A commit transaction account ownership changes from $\mathsf{ssk}, \mathsf{tsk}$ to $\mathsf{rsk}$ based on some epoch $\mathsf{time}$, i.e. for any PPT adversary $\mathcal{A}$ it holds that \\
$\mathsf{Pr}\left[
    \begin{cases} 
	\mathsf{SrcChk}(\mathsf{ac}, r, (\mathsf{ssk}, \mathsf{tsk}, \perp), \mathsf{accd}, \mathsf{time}+1) \tabularnewline 
	\mathsf{SrcChk}(\mathsf{ac}, r, (\perp, \perp, \mathsf{rsk}), \mathsf{accd}, \mathsf{time}-1) \tabularnewline
        \Gamma.\mathsf{Com}(\mathsf{accd}, r) = \mathsf{co} 
    \end{cases} 
    \middle|(
    \begin{aligned}
	(\mathsf{pp}, \mathsf{st}) \gets \mathsf{Setup}(1^\lambda) \\
	\mathsf{ac}, \mathsf{ssk}, \mathsf{tsk}, \mathsf{rsk}, \mathsf{accd}) \gets \mathcal{A}(\mathsf{pp}) \\
    	\mathsf{time} := \mathbf{parse} \: \mathsf{accd} \\
    \end{aligned}
\right]
\leq \negl
$
\end{definition}

\begin{figure}[H]
\begin{pchstack}[center, boxed]
\pseudocode{
    \text{Balance} \\[0.1\baselineskip ][\hline] 
    (\mathsf{pp}, \mathsf{st}_0) \gets \mathsf{Setup}(1^\lambda) \\
    (\mathsf{tx}_i)_{i \in \mathbb{Z}_l} \gets \mathcal{A}(\mathsf{pp}, \mathsf{st}_0) \\
    (P_i, R_i, S_i, T_i)_{i \in \mathbb{Z}_{l}} \gets \mathcal{E}_{\mathsf{A}} (\mathsf{pp}, \mathsf{st}_0, (\mathsf{tx}_i)_{i \in \mathbb{Z}_{l}}) \\
    \{ \mathsf{sks}_{i,j}, \mathsf{accd}_{i,j} \}_{j \in S_i} := \mathbf{parse} \: (S_i)_{i \in \mathbb{Z}_{l}} \\
    \{ \mathsf{mpks}_{i,j},\mathsf{tk}_{i,j}, \mathsf{accd}'_{i,j} \}_{j \in T_i}) := \mathbf{parse} \: (T_i)_{i \in \mathbb{Z}_{l}} \\
    \mathbf{for} \: t \in \mathbb{Z}_l \: \mathbf{do} \: (b_t, \mathsf{st}_{t+1}) := \mathsf{Vf}(\mathsf{st_t}, \mathsf{tx_t}) \\
    \mathbf{for} \: i \in \mathbb{Z}_l \: \mathbf{do} \\
    \qquad \mathsf{accd}_{i, S_i} := (\mathsf{accd}_{i,j})_{j \in S_i},
    \mathsf{accd}'_{i, T_i} := (\mathsf{accd}'_{i,j})_{j \in T_i} \\
    \qquad \{ \mathsf{ac}_{i,j} \}_{j \in U_i} := \mathsf{StExt}(\mathsf{st}_i), \{ \mathsf{ac'}_{i,j} \}_{j \in T_i} := \mathsf{TxExt}(\mathsf{tx}_i) \\
    \qquad b'_i := 
    \begin{cases}
	\mathsf{TxExt} \subseteq \mathsf{StExt}(\mathsf{st}_{i+1}) \vspace{0.3em} \tabularnewline
	P_i \in \mathcal{P} \tabularnewline
	P_i(\mathsf{accd}_{i, S_i}, \mathsf{accd}'_{i, T_i}) \vspace{0.3em} \tabularnewline
	S_i \subseteq R_i \subseteq U_i \vspace{0.3em} \tabularnewline
	\mathsf{SrcChk}(\mathsf{StExt}(\mathsf{st}_i)[j], \mathsf{sks}_{i,j}, \mathsf{accd}_{i,j}) = 1 \:\:\: \forall j \in \mathsf{S}_i \vspace{0.3em} \tabularnewline
	\mathsf{TgtChk}(\mathsf{TxExt}(\mathsf{tx}_i)[j], \mathsf{mpks}_{i,j}, \mathsf{accd}_{i,j}) = 1 \:\:\: \forall j \in \mathsf{S}_i \vspace{0.3em} \tabularnewline
    \end{cases} \\
    b'' := (\exists i_0 < i_1, S_{i_0} \cap S_{i_1} = \emptyset) \\
    \mathbf{return} \bigwedge_{i \in \mathbb{Z}_l} b_i \land \neg (\bigwedge_{i \in \mathbb{Z}_l} b_i' \land b_i'')
}
\end{pchstack}
\caption{Balance experiment definition}
\end{figure}

\begin{figure}
\begin{minipage}[t]{\textwidth}
\begin{pchstack}[boxed]
\begin{pcvstack}
\pseudocode{
    \mathsf{KGen}\mathcal{O}(\mathsf{id}) \\[0.1\baselineskip ][\hline]
    \mathbf{if} \: \mathsf{id} \notin \mathsf{ID} \\
    \qquad (\mathsf{mpk},\mathsf{msk}) \gets \mathsf{KGen}(\mathsf{pp}) \\
    \qquad (\mathsf{MPK}, \mathsf{MSK})[\mathsf{id}] := (\mathsf{mpk},\mathsf{msk}) \\
    \mathsf{ID} := \mathsf{ID} \cup \{\mathsf{id}\} \\
    \mathbf{return} \: \mathsf{MPK}[\mathsf{id}]
}
\vspace{1em}
\pseudocode{
	\mathsf{Corr}\mathcal{O}(\mathsf{id}) \\[0.1\baselineskip ][\hline]
        \mathbf{if} \: \mathsf{id} \notin \mathsf{ID}^* \: \mathbf{return} \: \perp \\
        * \gets \mathsf{KGen}\mathcal{O}(\mathsf{id}) \\
        \mathsf{ID}^* := \mathsf{ID}^* \cup \{\mathsf{id}\} \\
        \mathsf{AC}^* := \bigcup_{\mathsf{id} \in \mathsf{ID}^*} \mathsf{AC}[\mathsf{id}] \\
        \mathbf{return} \: \mathsf{MSK}[\mathsf{id}]
}
\vspace{1em}
\pseudocode{
	\mathsf{Vf}\mathcal{O}(\mathsf{tx}) \\[0.1\baselineskip ][\hline]
        \mathbf{return} \: \mathsf{Vf}(\mathsf{st}, \mathsf{tx})
}
\end{pcvstack}
\qquad
\begin{pcvstack}
\pseudocode{
	\mathsf{Trans}\mathcal{O}(P, R, \mathcal{S'}, \mathcal{T'}, \mathcal{S}^*, \mathcal{T}^*) \\[0.1\baselineskip ][\hline]
	 \{\mathsf{ssk}_i, \mathsf{accd}_i\}_{i \in S'} := \mathbf{parse} \: \mathcal{S'}  \\
	 \{\mathsf{id}_i, \mathsf{tk}_i\}_{i \in S^*} := \mathbf{parse} \: \mathcal{S}^*  \\
	 \{\mathsf{mpk}_i, \mathsf{accd}'_i\}_{i \in T'} := \mathbf{parse} \: \mathcal{T'} \\
	 \{\mathsf{id}'_i, \mathsf{accd}'_i\}_{i \in T^*} := \mathbf{parse} \: \mathcal{T}^*  \\
         \mathbf{if} \: \mathcal{S}^* \cap \mathcal{S}' \neq \emptyset \lor \mathcal{T}' \cap \mathcal{T}^* \: \mathbf{return} \perp \\
         \mathbf{if} \: (\{\mathsf{id_i}_{i\in S^*}\} \cup \{\mathsf{id_i}_{i\in T^*}\}) \cap \mathsf{ID}^* \neq \emptyset \: \mathbf{return} \perp \\
         \mathbf{if} \: \mathsf{StExt}(\mathsf{st})[\mathcal{S}^*] \cap \mathsf{AC}^* \neq \emptyset \: \mathbf{return} \perp \\
         \mathcal{S} := \mathcal{S}' \cup \{\mathsf{KDer}(\mathsf{MSK}[\mathsf{id}_i], \mathsf{tk}_i)\}_{i \in S^*} \\
         \mathcal{T} := \mathcal{T}' \cup \{\mathsf{MPK}[\mathsf{id}'_i], \mathsf{accd}'_i\}_{i\in T^*} \\
         (\mathsf{tx}, \mathsf{TK}) \gets \mathsf{Trans}(\mathsf{st}, P, R, \mathcal{S}, \mathcal{T}) \\
         \mathsf{AC}[\mathsf{id'}_i] := \mathsf{AC}[\mathsf{id'}_i] \cup \mathsf{TxExt}(\mathsf{tx})[i], \forall i \in T \\
         \mathbf{return} \: (\mathsf{tx}, \mathsf{TK})
}
\end{pcvstack}
\end{pchstack}
\end{minipage}%
\end{figure}

\begin{definition}[Privacy] A RingCCT scheme is private if: \\
\end{definition}

\begin{figure}[H]
\begin{pchstack}[center, boxed]
\pseudocode{
    \mathsf{Privacy}^b_{\mathcal{A}} \\[0.1\baselineskip ][\hline] 
    (\mathsf{pp}, \mathsf{st}) \gets \mathsf{Setup}(1^\lambda) \\
    \mathcal{O} := \{\mathsf{KGen}\mathcal{O}, \mathsf{Corr}\mathcal{O}, \mathsf{Trans}\mathcal{O}, \mathsf{Vf}\mathcal{O}\} \\
    (P,R, \mathcal{S}', \mathcal{T}', (\mathcal{S}^*_i, \mathcal{T}^*_i)_{i \in \{0,1\}}) \gets \mathcal{A}^\mathcal{O}(\mathsf{pp}) \\
    \mathbf{for} i \in \{0, 1\} \\
    \:\: (\mathsf{tx}_i, *) \gets \mathsf{Trans}\mathcal{O}(P, R, \mathcal{S}', \mathcal{T}', \mathcal{S}^*_i, \mathcal{T}^*_i)
    \:\: (b_i, \mathsf{st'_i}) := \mathsf{Vf}(\mathsf{st}, \mathsf{tx}_i) \\
    \:\: \mathbf{if} b_i = 0 \mathbf{return} \: 0 \\
    \{ \mathsf{id}_{i,j},\mathsf{tk}_{i,j} \}_{j\in S^*_i} := \mathbf{parse} \: \mathcal{S}^*_i \\
    \{ \mathsf{id}'_{i,j},\mathsf{accd}_{i,j} \}_{j\in S^*_i} := \mathbf{parse} \: \mathcal{T}^*_i \\
    \mathsf{ID}^* := \mathsf{ID}^* \cup \{\mathsf{id}_{i,j}\}_{j\in S^*_i} \cup \{\mathsf{id;}_{i,j}\}_{j\in T^*_i} \\
    \mathsf{AC}^* := \mathsf{AC}^* \cup \mathsf{StExt}(\mathsf{st})[\mathcal{S}^*_i] \cup \mathsf{TxExt}(\mathsf{tx}_i)[\mathcal{T}^*_i] \\
    \mathbf{if} (|\mathcal{S^*_0}| \neq |\mathcal{S^*_1}|) \lor (|\mathsf{StExt}(\mathsf{st}'_0) \ \mathsf{StExt}(\mathsf{st})| \neq |\mathsf{StExt}(\mathsf{st}'_1) \ \mathsf{StExt}(\mathsf{st})|) \:\: \mathbf{return} \: 0 \\
    b' \gets \mathcal{A}^\mathcal{O}(\mathsf{tx}_b) \\
    \mathbf{return} \: b'
}
\end{pchstack}
%\caption{Privacy experiment definition}
\end{figure}



\begin{definition}[Availability] A RingCCT scheme is available if: \\
\end{definition}

\begin{figure}[H]
\begin{pchstack}[center, boxed]
\pseudocode{
    \mathsf{Available}_{\mathcal{A}} \\[0.1\baselineskip ][\hline] 
    (\mathsf{pp}, \mathsf{st}) \gets \mathsf{Setup}(1^\lambda) \\
    \mathcal{O} := \{\mathsf{KGen}\mathcal{O}, \mathsf{Corr}\mathcal{O}, \mathsf{Trans}\mathcal{O}, \mathsf{Vf}\mathcal{O}\} \\
    (P,R, \mathcal{S}', \mathcal{T}', (\mathcal{S}^*_i, \mathcal{T}^*_i)_{i \in \{0,1\}}) \gets \mathcal{A}^\mathcal{O}(\mathsf{pp}) \\
    (\mathsf{tx}, \mathsf{TK}) \gets \mathsf{Trans}\mathcal{O}(P, R, \mathcal{S}', \mathcal{T}', \mathcal{S}^*_i, \mathcal{T}^*_i)
    \{ \mathsf{id}_j,\mathsf{tk}_j \}_{j\in S^*} := \mathbf{parse} \: \mathcal{S}^* \\
    \mathbf{if} \mathcal{S}^* \not\subseteq U \mathbf{return} \: 0 \\
    (\mathsf{ID}^*, \mathsf{AC}^*) := (\{id_j\}_{j \in S^*}, \mathsf{StExt}(\mathsf{st})[\mathcal{S}^*])
    (b, \perp) := \mathsf{Vf}(\mathsf{st}, \mathsf{tx}) \\
    \perp \gets \mathcal{A}\mathcal{O}(\mathsf{tx}, \mathsf{TK}) \\
    (b', \perp) := \mathsf{Vf}(\mathsf{st}, \mathsf{tx}) \\
    \mathbf{return} \: b' \land b'
}
\end{pchstack}
%\caption{Privacy experiment definition}
\end{figure}

\newpage

\subsection*{Construction}

\begin{equation*}
\mathcal{R}(\mathsf{stmnt}, \mathsf{wit}) := \begin{cases} 
    S \subseteq R \\ 
    \xi_{\phi S(i)} = \Delta.\mathsf{Eval}(s_i) \qquad \forall i \in S \\
    \mathsf{SrcChk}(\mathsf{ac}_i, r, \mathsf{sks}_i, \mathsf{accd}_i, \mathsf{time}, \mathsf{type}) = 1 \qquad \forall i \in S \\ 
    \mathsf{TgtChk}(\mathsf{ac'}_i, \mathsf{accd}'_i) = 1 \qquad \forall i \in T \\ 
    P(a_S, a'_T) = 1
\end{cases}
\end{equation*}

\begin{equation*}
\mathsf{stmnt} := (P,\mathsf{AC}_R,\mathcal{Z}_{\bar{S}}, \mathsf{AC}_T, \mathsf{time}, \mathsf{type}) \\
\end{equation*}
\begin{equation*}
\mathsf{wit} := ((r,\mathsf{sks}_i, \mathsf{accd}_i)_{i\in S}), (\mathsf{mpks}_i, \mathsf{accd}'_i)_{i\in T}) \\
\end{equation*}



\begin{figure}
\begin{minipage}[t]{\textwidth}
\begin{pchstack}[boxed]

\begin{pcvstack}
\pseudocode{
    \mathsf{Setup}(1^\lambda) \\ [0.1\baselineskip ][\hline]
    \mathsf{crs} \gets \Pi.\mathsf{Setup}(1^\lambda) \\
    \mathsf{ck} \gets \Gamma.\mathsf{Gen}(1^\lambda) \\
    \mathsf{pp_\Delta} \gets \Delta.\mathsf{Setup}(1\lambda) \\
    \mathbf{return} \: (\mathsf{pp}, \mathsf{st})
}
\vspace{1em}
\pseudocode{
    \mathsf{KGen}(\mathsf{pp}) \\[0.1\baselineskip ][\hline]
    \mathsf{msk} \sample\mathcal{K} \\
    \mathsf{mpk} := \Delta.\mathsf{KGen(msk)} \\
    \mathbf{return} \: (\mathsf{mpk}, \mathsf{msk})
}
\vspace{1em}
\pseudocode{
    \mathsf{TimeExt}(\mathsf{st}) \\[0.1\baselineskip ][\hline]
    \mathsf{time} := \mathbf{parse} st \\
    \mathbf{return} \: \mathsf{time}
}
\vspace{1em}
\pseudocode{
    \mathsf{Vf}(\mathsf{st},\mathsf{tx}) \\[0.1\baselineskip ][\hline]
    (\mathsf{AC}_U, \mathcal{Z}_U) := \mathbf{parse} \: \mathsf{st} \\
    \{\mathsf{ac}_i\}_{i \in U} := \mathbf{parse} \: \mathsf{AC}_U \\
    (P,R,\mathsf{AC}_T, \mathcal{Z}_{\bar{S}}) := \mathbf{parse} \: \mathsf{tx} \\
    \mathsf{AC}_R := \{\mathsf{ac}_i\}_{i \in R} \\
    \mathsf{stmnt} := (P,\mathsf{AC}_R,\mathsf{AC}_T,\mathcal{Z}_{\bar{S}}, \mathsf{type}, \mathsf{time}) \\
    \mathbf{if} \: \begin{cases}
        P \in \mathcal{P} \tabularnewline
        R \subseteq U \tabularnewline
        \Pi.\mathsf{Vf}(\mathsf{crs}, \mathsf{stmnt}, \pi) = 1 \tabularnewline
        \mathcal{Z}_{\bar{S}} \cap \mathcal{Z}_{\bar{U}} = \emptyset
    \end{cases} \: \mathbf{then} \\
    \:\: \mathbf{return} \: (1, \mathsf{st}') \\
    \mathbf{else} \: \mathbf{return} \: (0, \mathsf{st})
}
\vspace{1em}
\pseudocode{
    \mathsf{TimeVf}(\mathsf{st}, \mathsf{tx}) \\[0.1\baselineskip ][\hline]
    \mathsf{time} := \mathbf{parse} \: \mathsf{st} \\
    \mathsf{type}, \mathsf{time}' := \mathbf{parse} \: \mathsf{tx} \\
    (\mathsf{ret}, \mathsf{st}') := \mathsf{Vf}(\mathsf{st}, \mathsf{tx}) \\
    \mathbf{if} \: \mathsf{ret} = 1 \\
    \:\: \mathbf{if} \: \mathsf{type} = 0 \: \lor \\
    \:\: \: (\mathsf{type} = 1 \land  \mathsf{time} \leq \mathsf{time}') \: \lor\\
    \:\: \: (\mathsf{type} = -1 \land  \mathsf{time} > \mathsf{time}') \\
    \:\:\:\:\:\: \mathbf{return} \: (1, \mathsf{st}') \\
    \mathbf{return} \: (0, \mathsf{st})
}
\vspace{1em}
\pseudocode{
    \mathsf{StExt}(\mathsf{st}) \\[0.1\baselineskip ][\hline]
    (\mathsf{AC}_U, \mathcal{Z}_U) := \mathbf{parse} \: \mathsf{st} \\
    \mathbf{return} \: \mathsf{AC}_U
}
\vspace{1em}
\pseudocode{
    \mathsf{TxExt}(\mathsf{tx}) \\[0.1\baselineskip ][\hline]
    (P,R,\mathsf{AC}_T, \mathcal{Z}_{\bar{S}}) := \mathbf{parse} \: \mathsf{tx} \\
    \mathbf{return} \: \mathsf{AC}_T
}
\vspace{1em}
\pseudocode{
    \mathsf{TgtChk}(\mathsf{ac}, \mathsf{accd}) \\[0.1\baselineskip ][\hline]
    \mathsf{co} := \mathbf{parse} \: \mathsf{ac} \\
    (r, \mathsf{accd}') := \mathbf{parse} \: \mathsf{tk} \\
    \mathbf{return} \: \begin{cases}
        %\mathsf{accd}' \overset{?}{=} \mathsf{accd} \tabularnewline
        \mathsf{co} \overset{?}{=} \Gamma.\mathsf{Com}(\mathsf{accd},r)
    \end{cases} 
}
\end{pcvstack}
\qquad
\begin{pcvstack}
\pseudocode{
    \mathsf{KDer}(\mathsf{msk},\tau) \\[0.1\baselineskip ][\hline]
    (r, \delta, \mathsf{accd} := (a, \mathsf{time}, \mathsf{type})) := \mathbf{parse} \: \tau \\
    \mathsf{sk} := \mathsf{msk}+\delta \\
    \mathbf{return} \: (\mathsf{sk}, r, \mathsf{accd})
}
\vspace{1em}
\pseudocode{
    \mathsf{TxGen}(\mathsf{st}, P, R, \mathcal{S}, \mathcal{T}) \\[0.1\baselineskip ][\hline]
    \{\mathsf{sks}_i, \mathsf{accd}_i\}_{i\in S} := \mathbf{parse} \: \mathcal{S} \\
    \{\mathsf{mpks}_i, \mathsf{accd}'_i\}_{i\in T} := \mathbf{parse} \: \mathcal{T} \\
    \mathbf{for} \; i \in T \: \mathbf{do} \\
    \:\: r'_i \sample \chi \\
    \:\: \delta'_i \sample \mathcal{K} \\
    \:\: \mathsf{co}'_i := \Gamma.\mathsf{Com}(\mathsf{accd}'_i, r'_i) \\
    \:\: (\mathsf{smpk}_i, \mathsf{tmpk}_i, \mathsf{rmpk}_i) := \mathbf{parse} \: \mathsf{mpks}_i \\
    \:\: \mathsf{spk}_i := \mathsf{smpk}_i + \Delta.\mathsf{Eval}(\delta''_i) \\
    \:\: \mathbf{if} \: \mathsf{rmpk}_i \neq \: \perp \land \: \mathsf{tmpk}_i \neq \: \perp \\
    \:\:\:\: \delta''_i \sample \mathcal{K} \\
    \:\:\:\: \delta'''_i \sample \mathcal{K} \\
    \:\:\:\: \mathsf{tpk}_i := \mathsf{tmpk}_i + \Delta.\mathsf{Eval}(\delta'_i) \\
    \:\:\:\: \mathsf{rpk}_i := \mathsf{rmpk}_i + \Delta.\mathsf{Eval}(\delta''_i) \\
    \:\:\:\: \mathsf{pks}_i := (\mathsf{spk}_i, \mathsf{tpk}_i, \mathsf{rpk}_i) \\
    \:\:\;\: \mathsf{tk}_i := (r'_i, \delta'_i, \delta''_i, \delta'''_i, \mathsf{accd}'_i) \\
    \;\: \mathbf{else} \\
    \:\:\:\: \mathsf{pks}_i := (\mathsf{spk}_i, \perp, \perp) \\
    \:\:\;\: \mathsf{tk}_i := (r'_i, \delta'_i, \mathsf{accd}'_i) \\
    \mathsf{ac}'_i := (\mathsf{pks}_i, \mathsf{co}'_i) \\
    \{\mathsf{ac}_i\}_{i \in U} := \mathsf{StExt(st)} \\
    \mathsf{AC}_R := \{\mathsf{ac}_i\}_{i \in R} \\
    \mathsf{AC}_T := \{\mathsf{ac}_i\}_{i \in T} \\
    \mathcal{Z}_{\bar{S}} := \{\Delta.\mathsf{Eval}(\mathsf{ssk}_i)\}_{\phi S(i)\in \bar{S}} \\
    \mathsf{stmnt} := (P,\mathsf{AC}_R,\mathsf{AC}_T,\mathcal{Z}_{\bar{S}}, \mathsf{time}, \mathsf{type}) \\
    \mathsf{wit} := ((r,\mathsf{sks}_i, \mathsf{accd}_i)_{i\in S}), (\mathsf{mpks}_i, \mathsf{accd}'_i)_{i\in T}) \\
    \pi \gets \Pi.\mathsf{Prove}(\mathsf{crs},\mathsf{stmnt},\mathsf{wit}) \\
    \mathsf{tx} := (P,\mathsf{AC}_R,\mathsf{AC}_T,\mathcal{Z}_{\bar{S}}, \pi) \\
    \mathsf{TK} := {\mathsf{tk}_i}_{i \in T} \\
    \mathbf{return} \: (\mathsf{tx}, \mathsf{TK})
}
\vspace{1em}
\pseudocode{
    \mathsf{SrcChk}(\mathsf{ac}, r, \mathsf{sks}, \mathsf{accd}, \mathsf{time}, \mathsf{type}) \\[0.1\baselineskip ][\hline]
    (\mathsf{ssk}, \mathsf{tsk}, \mathsf{rsk}) := \mathbf{parse} \: \mathsf{sks} \\
    (\mathsf{pks}, \mathsf{co}) := \mathbf{parse} \: \mathsf{ac} \\
    (\mathsf{spk}, \mathsf{tpk}, \mathsf{rpk}) := \mathbf{parse} \: \mathsf{pks} \\
    \mathsf{accd} := (a, \mathsf{time'}, \mathsf{type'}) \\
    \mathbf{if} \: \mathsf{co} \neq \Gamma.\mathsf{Com}(\mathsf{accd}, r) \\
    \:\: \mathbf{return} \: 0 \\
    \mathbf{if} \: \mathsf{type} = \: 0 \\
    \:\: \mathbf{return} \: \mathsf{spk} \overset{?}{=} \Delta.\mathsf{KGen}(\mathsf{ssk}) \\
    \mathbf{else} \: \mathbf{if} \: \mathsf{type} = 1  \\
    \:\: \mathbf{return} \: \begin{cases}
        \mathsf{tpk} \overset{?}{=} \Delta.\mathsf{KGen}(\mathsf{tsk}) \tabularnewline
        \mathsf{spk} \overset{?}{=} \Delta.\mathsf{KGen}(\mathsf{ssk}) \tabularnewline
    \end{cases} \\
    \mathbf{else} \\
    \:\: \mathbf{return} \: \mathsf{rpk} \overset{?}{=} \Delta.\mathsf{KGen}(\mathsf{rsk}) \\
}
\end{pcvstack}
\end{pchstack}
\end{minipage}%
\end{figure}

\newpage

\section{Commit transaction based atomic swaps}

\begin{figure}[H]
\begin{pchstack}[center, boxed]
\pseudocode{
    P_0(\mathsf{ssk_{\mathbb{A}}},\mathsf{rsk_{\mathbb{A}}},\mathsf{tsk_{\mathbb{B}}}) \qquad \qquad P_1(\mathsf{ssk_{\mathbb{B}}},\mathsf{rsk_{\mathbb{B}}},\mathsf{tsk_{\mathbb{A}}}) \\[0.1\baselineskip ][\hline] 
    \<\< \\[-0.4\baselineskip ]
    \mathcal{S_\mathbb{A}} := (\mathsf{ssk}_\mathbb{A}, \mathsf{rsk}_\mathbb{A}, \mathsf{tsk}_\mathbb{A}, \mathsf{accd}_\mathbb{A}) \\
    \mathsf{(tx_\mathbb{A}, TK_\mathbb{A})} := \mathsf{TxGen_\mathbb{A}}(\mathsf{st},P,R,\mathcal{S},\mathcal{T}) \\
    \mathcal{S_\mathbb{B}} := (\mathsf{ssk}_\mathbb{B}, \mathsf{rsk}_\mathbb{B}, \mathsf{tsk}_\mathbb{B}, \mathsf{accd}_\mathbb{B}) \\
    \mathsf{(tx_\mathbb{B}, TK_\mathbb{B})} := \mathsf{TxGen_\mathbb{B}}(\mathsf{st},P,R,\mathcal{S},\mathcal{T}) \\
    \mathbf{output} \: \mathsf{(tx_\mathbb{A} \oplus \mathsf{tx_\mathbb{B}}, TK_\mathbb{A})} \: \mathbf{to} \: P_1 \\
    \mathbf{output} \: \mathsf{(tx_\mathbb{B}, TK_\mathbb{B})} \: \mathbf{to} \: P_0 \\
}
\end{pchstack}
\caption{Protocol definition of 2PC $\Gamma_{\mathsf{CommitTx}}$}
\end{figure}


\begin{figure}[H]
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (T, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    \mathsf{(rmpk, rmsk)} \gets \mathsf{KGen}_\mathsf{A}(\mathsf{pp}) \\
    \mathcal{S}_0 := \{(\mathsf{ssk}_\mathsf{A}, \perp, \perp, (\mathsf{amnt_a}, \perp))\} \\
    \mathcal{T}_0 := \{(\mathsf{smpk}_\mathsf{A}, \mathsf{tmpk}_\mathsf{A}, \mathsf{rmpk}_\mathsf{A}, (\mathsf{amnt_a}, T_0))\} \\
    \mathsf{(tx_0, TK_0)}_\mathbb{A} := \mathsf{TxGen_\mathbb{A}}(\mathsf{st},P,R,\mathcal{S}_0,\mathcal{T}_0) \\
    (\_, \mathsf{st}') := \mathsf{Vf}_\mathbb{A}(\mathsf{tx_0}) \\
    \mathsf{send}(\mathsf{(tx_0, TK_0)}_\mathbb{A}) \\
    \mathsf{\textbf{select}} \:\: \{ \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{timeout}(T_0) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{receive}(\mathsf{(tx_0, TK_0)}_\mathbb{B}) \\
    \qquad (\mathsf{res}, \mathsf{st}') := \mathsf{Vf}_\mathbb{B}(\mathsf{tx_0}) \\
    \qquad \mathsf{\textbf{if}} \:\: \mathsf{res} \neq 1 \\ % verify that commit transaction is valid and accepted
    \qquad \quad \mathsf{\textbf{return}} \perp \\
    \qquad (\mathsf{tx_1, TK_1}) \gets \Gamma.\mathsf{CommitTx}(\mathsf{ssk_\mathbb{A}}, \mathsf{rsk_\mathbb{A}}, \mathsf{tsk_\mathbb{B}}) \\
    \qquad (\mathsf{res}, \mathsf{st}') := \mathsf{Vf}_\mathbb{B}(\mathsf{tx_1}) \\
    \qquad \mathsf{\textbf{if}} \:\: \mathsf{res} \neq 1 \\ % verify that commit transaction is valid and accepted
    \qquad \quad \mathsf{\textbf{return}} \perp \\
    \quad \} \\
    \} \\
}
\end{pchstack}
\end{minipage}%
\hspace{0.4cm}
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (T, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    \mathsf{(rmpk, rmsk)} \gets \mathsf{KGen}_\mathsf{B}(\mathsf{pp}) \\
    \mathcal{S}_0 := \{(\mathsf{ssk}_\mathsf{B}, \perp, \perp, (\mathsf{amnt_b}, \perp))\} \\
    \mathcal{T}_0 := \{(\mathsf{smpk}_\mathsf{B}, \mathsf{tmpk}_\mathsf{B}, \mathsf{rmpk}_\mathsf{B}, (\mathsf{amnt_b}, T_1))\} \\
    \mathsf{(tx_0, TK_0)}_\mathbb{B} := \mathsf{TxGen_\mathbb{B}}(\mathsf{st},P,R,\mathcal{S}_0,\mathcal{T}_0) \\
    (\_, \mathsf{st}') := \mathsf{Vf}_\mathbb{B}(\mathsf{tx_0}) \\
    \mathsf{send}(\mathsf{(tx_0, TK_0)}_\mathbb{B}) \\
    \mathsf{\textbf{select}} \:\: \{ \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{timeout}(T_1) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{receive}(\mathsf{(tx_0, TK_0)}_\mathbb{A}) \\
    \qquad (\mathsf{res}, \mathsf{st}') := \mathsf{Vf}_\mathbb{A}(\mathsf{tx_0}) \\
    \qquad \mathsf{\textbf{if}} \:\: \mathsf{res} \neq 1 \\ % verify that commit transaction is valid and accepted
    \qquad \quad \mathsf{\textbf{return}} \perp \\
    \qquad (\mathsf{lk, TK_1}) \gets \Gamma.\mathsf{CommitTx}(\mathsf{ssk_\mathbb{B}}, \mathsf{rsk_\mathbb{B}}, \mathsf{tsk_\mathbb{A}}) \\
    \qquad (\mathsf{res}, \mathsf{st}') := \mathsf{Vf}_\mathbb{B}(\mathsf{tx_1}) \\
    \qquad \mathsf{\textbf{if}} \:\: \mathsf{res} \neq 1 \\ % verify that commit transaction is valid and accepted
    \qquad \quad \mathsf{\textbf{return}} \perp \\
    \quad \} \\
    \} \\
}
\end{pchstack}
\end{minipage}%
\caption{Full protocol execution for $P_0$ and $P_1$, respectively left and right}
\end{figure}

\subsection{Efficient 2PC}
\vspace{1em}

$[M_0] := \begin{pmatrix}
[1] & 0 & 0 & -[s] \\
0 & [1] & 0 & -[t] \\
0 & 0 & [1] & -[r]
\end{pmatrix} $
$w_1 := \begin{bmatrix} s \\ t \\ r \\ 1 \\ \end{bmatrix}$
$[w_2] := \begin{pmatrix}
1-b & 0 & 0 \\
0 & c(1-b) & 0 \\
0 & 0 & b \\
\end{pmatrix}$
$[0] :=
\begin{pmatrix}
0 & 0 & 0 \\
0 & 0 & 0 \\
0 & 0 & 0 \\
\end{pmatrix} $
$([M_0]w_1)^T[w_2] = [0]$

\end{document}
