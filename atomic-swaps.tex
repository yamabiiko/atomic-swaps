\documentclass{article}      	% Style of the document                     
\usepackage{fullpage}
\usepackage{amsmath}     	   	% Maths                                          
\usepackage[utf8]{inputenc}	% UTF-8 characters                                               
\usepackage[T1]{fontenc}    	% Tuki ääkkösille (Finnish names don't cause problems)                                            
\usepackage{parskip}        		% Linebreak between paragraphs                
\usepackage{graphicx}       		% Graphics package for adding figures                        
\usepackage{epstopdf}       		% Possibility to add *.eps figures
 \usepackage{ dsfont }            % Symbol for real numbers
\usepackage{hyperref}
\usepackage{extarrows}
\usepackage{float}
\usepackage{makeidx}
\usepackage{enumitem}        % possibility to label list items by alphabet
\newcommand{\M}[1]{\ensuremath{\text{\texttt{#1}}}}
\usepackage[
    lambda,
    operators,
    advantage,
    sets,
    adversary,
    landau,
    probability,
    notions,
    logic,
    ff,
    mm,
    primitives,
    events,
    complexity,
    asymptotics,
    keys]{cryptocode}

\usepackage{todonotes}

 \usepackage{amsmath,amsfonts,graphicx,amssymb,amsthm}
\mathchardef\mhyphen="2D

 %% general
\mathchardef\mhyphen="2D
\newcommand{\fdv}{\mathcal{F}}
\newcommand{\tdv}{\mathcal{T}}
\newcommand{\vdv}{\mathcal{V}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\ID}{\mathcal{I}}
\newcommand{\bits}[1][]{\{0,1\}^{#1}}
\renewcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\mat}[1]{\mathbf{#1}}
\newcommand{\inner}[2]{\langle #1, #2 \rangle}
\newcommand{\transpose}{\mathtt{T}}
\newcommand{\round}[1]{\lfloor #1 \rceil}
\renewcommand{\dist}{\mathsf{dist}}
\renewcommand{\Pr}[2][]{{\text{Pr}_{#1}\left[#2\right]}}
\newcommand{\Exp}[2][]{{\mathbb{E}_{#1}\left[#2\right]}}
\newcommand{\mathcm}[2][1cm]{\hspace{#1}{\mbox{/\!\!/ } \text{\scriptsize#2}}}

%% lattice problems
\newcommand{\SIS}{\mathsf{SIS}}
\newcommand{\ISIS}{\mathsf{ISIS}}
\newcommand{\nfSIS}{\mathsf{nfSIS}}
\newcommand{\dSIS}{\mathsf{dSIS}}
\newcommand{\LWE}{\mathsf{LWE}}
\newcommand{\nfLWE}{\mathsf{nfLWE}}
\newcommand{\nfdLWE}{\mathsf{nfdLWE}}
\newcommand{\sLWE}{\mathsf{sLWE}}
\newcommand{\dLWE}{\mathsf{dLWE}}
\newcommand{\SVP}{\mathsf{SVP}}
\newcommand{\CVP}{\mathsf{CVP}}
\newcommand{\SIVP}{\mathsf{SIVP}}
\newcommand{\GapSVP}{\mathsf{GapSVP}}
\newcommand{\BDD}{\mathsf{BDD}}
\newcommand{\NTRU}{\mathsf{NTRU}}
\newcommand{\sNTRU}{\mathsf{sNTRU}}
\newcommand{\dNTRU}{\mathsf{dNTRU}}

%% lattice macros
\newcommand{\TT}{\mathbb{T}}
\newcommand{\ring}{\mathcal{R}}
\newcommand{\lattice}{\mathcal{L}}
\newcommand{\piped}{\mathcal{P}}
\newcommand{\ball}{\mathcal{B}}
\newcommand{\Hyb}{\mathsf{Hyb}}
\newcommand{\lspan}{\mathsf{span}}
\newcommand{\rank}{\mathsf{rank}}
\newcommand{\lsb}{\mathsf{LSB}}
\newcommand{\pubparam}{\mathsf{pp}}

%% group macros

%% syntax
\newcommand{\mpk}{\mathsf{mpk}}
\newcommand{\msk}{\mathsf{msk}}
\newcommand{\msg}{\mathsf{msg}}
\newcommand{\rnd}{\mathsf{rnd}}
\newcommand{\ctxt}{\mathsf{ctxt}}
\newcommand{\com}{\mathsf{com}}
\newcommand{\td}{\mathsf{td}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\stmt}{\mathsf{stmt}}
\newcommand{\wit}{\mathsf{wit}}
\newcommand{\tx}{\mathsf{tx}}
\newcommand{\aux}{\mathsf{aux}}
\newcommand{\ek}{\mathsf{ek}}

\newcommand{\Setup}{\mathsf{Setup}}
\newcommand{\Commit}{\mathsf{Com}}
\newcommand{\TrapGen}{\mathsf{TrapGen}}
\newcommand{\SampD}{\mathsf{SampD}}
\newcommand{\SampPre}{\mathsf{SampPre}}
\newcommand{\Prove}{\mathsf{Prove}}
\newcommand{\Verify}{\mathsf{Verify}}
\newcommand{\val}{\mathsf{val}}

%% primitive/scheme name
\newcommand{\PKE}{\mathsf{PKE}}
\newcommand{\LTDF}{\mathsf{LTDF}}
\newcommand{\rsagen}{\mathsf{RSAGen}}
\newcommand{\rsa}{\mathsf{RSA}}
\newcommand{\LHE}{\mathsf{LHE}}
\newcommand{\CS}{\mathcal{CS}}
\newcommand{\NTRUEncrypt}{\mathsf{NTRUEncrypt}}

%% others
\newcommand{\oracle}{\mathcal{O}}
\newcommand{\pcas}{~\mathbf{as}~}

\newcommand{\polylog}[1][\secpar]{\mathsf{polylog}(#1)}

\newcommand{\indrsidcpa}{\mathrm{IND\$}\mhyphen\mathrm{sID}\mhyphen\mathrm{CPA}}
%\newcommand{\oplus}{\, \texttt{XOR} \,} % shorthand for typing the XOR operator in mathmode


\usepackage{biblatex}
\addbibresource{references.bib}


\begin{document}         
\author{Lorenzo Tucci}
\title{Atomic swaps}

\maketitle

\tableofcontents
\section{Introduction}

An atomic swap cross-chain swap is an exchange of assets held at two different blockchains between two users without any additional trust assumption. \\
Consider two ledgers $\mathbb{A}$ and $\mathbb{B}$, where Alice holds assets $a$ in $\mathbb{A}$ and Bob holds assets beta in $\mathbb{B}$. We want to ensure that Alice transfers her assets $a$ in $\mathbb{B}_a$ to Bob if and only if Bob transfers his asset $b$ to Alice in $\mathbb{B}_b$. \\

The word \textit{atomic} implies that the protocol execution can only have two possible outcomes: \\
1) the asset swap is successful, with Bob owning $a$ in $\mathbb{A}$ and Alice owning $b$ in $\mathbb{B}$ \\
2) the swap aborts with an asset refund, so Alice owns $a$ in $\mathbb{A}$ and Bob owns $b$ in $\mathbb{B}$ \\


\todo[inline]{TODO starts}
\begin{itemize}
\item General description of problem (swapping), motivations, etc.
\item Introduce Universal Atomic Swaps (UAS) and its building blocks, briefly discuss how the protocol works, and highlight the issue of both parties needing to solve a VTS
\item The ``our contribution'' subsection: e.g. ``We propose an alternative construction ... we provide an open source implementation ...''
\item (Not so) Related work (subsection or section): Other ways to get atomic swaps, e.g. TEE, relays, HTLC, ...
\end{itemize}

\todo[inline]{TODO ends}

\subsection{Existing solutions}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Type} & \textbf{Trustless} & \textbf{Transparent} & \textbf{Scriptless} \\
\hline
TEE [BJZLZBDJ'17] & & \checkmark & \checkmark \\
\hline
HTLC [Gugger '20] & \checkmark & &\\
\hline
Relays [LMP'21] & \checkmark & &  \\
\hline
Universal [MTS'20] & \checkmark & \checkmark & \checkmark \\
\hline
\end{tabular}
\caption{Properties comparison of different atomic swaps protocol}
\end{table}
\subsubsection{Hashed Timelock Contract (HTLC)}

Using a blockchain's scripting language and timelock functionalities it is possible to create a script that functions as a timed escrow that can be claimed if some condition is satisfied or refunded when expired. \\
More specifically, a hash-time lock contract (HTLC) has on input a tuple $(\mathsf{amnt_a}, h, T, \mathsf{pk_0}, \mathsf{pk_1})$ where $\mathsf{amnt_a}$ denotes the amount of $\mathsf{a}$ assets to be exchanged, $h$ is a hash value, $T$ the timeout, $\mathsf{pk_0}$ and $\mathsf{pk_1}$ the public key addresses of
two users, the HTLC transfers $\mathsf{amnt_a}$ to $\mathsf{pk_1}$ if invoked before timeout $T$ with input value $r$ such that $\mathcal{H}(r) = h$. 
If the contract is invoked after timeout $T$, it refunds the assets $\mathsf{amnt_a}$ to $\mathsf{pk_0}$ unconditionally. \\

Using HTLCs as a building block, an atomic swap protocol can be constructed as follows: \\
Alice chooses $r$, computes $h = \mathcal{H}(r)$, transfers $\mathsf{amnt_a}$ into an $(\mathsf{amnt_a}, h, T_0, \mathsf{pk_0}, \mathsf{pk_1})$ on blockchain $\mathbb{A}$ and sends $h,T$ to Bob. \\
Bob finishes the setup of the exchange by choosing a time $T_1 < T_0$ and transferring his $\mathsf{amnt_b}$ assets into an HTLC$(\mathsf{amnt_b}, h, T_1, \mathsf{pk_1}, \mathsf{pk_0})$ on blockchain $\mathbb{B}$. We note that Bob cannot claim the HTLC yet as $r$ is only known by Alice, thus there are only two possible outcomes: \\

(1) Alice claims the HTLC on $\mathbb{B}$ before $T_0$, effectively revealing $r$ to bob (and anyone observing $\mathbb{B}$), Bob can then proceed to compute $h = \mathcal{H}(r)$ to claim the counterpart HTLC on chain $\mathbb{A}$ \\
(2) Alice does not claim the HTLC on $\mathbb{B}$ in time and thus Bob cannot claim the HTLC on $\mathbb{A}$. After the respective timeouts they can refund the assets by invoking the contracts.

We note that this functionality can be realized without requiring complex scripting functionality \cite{h4sh3d} using semi-scriptless scripts. \\
A slightly different protocol can also be realized even if only one blockchain supports HTLCs or timelocks, as done in \cite{h4sh3d} for the Monero counterpart.
\todo[inline]{explain (splitting secret key, BTC party needs to move first)}

%\subsubsection{Relays}
%Another strategy to achieve atomic swaps relies on relays. Relays are abstractions (in general a smart contract or a script) hosted on some
%chain $\mathbb{B}_a$ that has light client like verification capabilities over chain $\mathbb{B}_b$. For each new block appended to chain $\mathbb{B}_a$,
%the block header is passed on to the relay on chain $\mathbb{B}_b$. \\
%The relay itself implements the standard verification procedure of chain $\mathbb{B}_a$’s consensus algorithm and can therefore verify the
%validity of the block. Once the proof of work has been verified,
%in the case of a Proof of Work (or PoW) blockchain, or the
%two-thirds of validators signatures, in the case of a Byzantine
%Fault Tolerant (or BFT) blockchain, it is possible to verify any
%transaction of chain $\mathbb{B}_a$ from chain $\mathbb{B}_b$. With light client
%like verification capabilities of chain $\mathbb{B}_a$ from chain $\mathbb{B}_b$,
%we can imagine the following scenario. Bob has X assets of
%chain $\mathbb{B}_b$. He is willing to exchange them for Y assets of
%chain $\mathbb{B}_a$.  \\
%    Bob sets up a smart contract SC1 and locks his
%assets in it (1). This smart contract SC1 is set to release the
%assets to anyone providing the proof that they made a payment
%of Y assets of chain $\mathbb{B}_a$ to Bob’s address. Alice, who is
%interested in this trade, transfers Y assets to Bob’s address (2).
%She retrieves the transaction hash tx and provide it to SC1 (3).
%SC1 calls the relay and asks for verification of transaction tx
%(4). The relay verifies that the transfer has taken place and if
%so, returns ok to SC1 (5). On receiving the answer from the
%relay, SC1 transfers the X assets of $\mathbb{B}_b$ to Alice’s address.

\subsubsection{Timed crypto}
While HTLCs can be an effective solution when supported, it is not possible to realize when both blockchains do not support timelocks. Furthermore, the transactions incure in higher execution costs due to scripting, and they are have additional on-chain data which may reduce privacy. \\

%\begin{figure}[H]
%\begin{pchstack}[center, boxed]
%\pseudocode{
%    \textbf{$P_0(pk(0)\:, sk(0)$)} \< \< \textbf{$P_1(pk(1)\:, sk(1))$} \\[0.1\baselineskip ][\hline] 
%    \<\< \\[-0.5\baselineskip ]
%    \< \sendmessage*{<->}{top={{\Gamma_{\mathsf{KeyGen}}(\mathbb{G},G,q)}}, bottom={\xlongleftarrow{} (sk_0(01), pk(01)) \\ (sk_1(01), pk(01)) \xlongrightarrow{} }} \< \\
%    \<\< (C, \pi) \gets \Pi_{\mathsf{VTD}}.\mathsf{Commit}(sk_1, T) \\
%    \< \sendmessageleft*{(C, \pi)} \< \\
%    \mathsf{starts}\: \mathsf{Timeout}(T - \Delta)
%    \<\< \mathsf{starts}\: \mathsf{Timeout}(T - \Delta) \\
%    \mathsf{if}\: \Pi_{\mathsf{VTD}}.\mathsf{Verify}(pk, C, \pi) \neq 1 \\
%    \qquad \mathsf{abort}\\
%    tx_\mathsf{frz} \gets \mathsf{InitTx}(pk(0), pk(01), \mathsf{swp(a)}, \mathbb{A}) \\
%    \sigma_{\mathsf{frz}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}(sk(0), tx_\mathsf{frz}) \\
%    \mathsf{PubTx}(\sigma_{\mathsf{frz}}, tx_\mathsf{frz}, \mathbb{A}) \\
%    \mathsf{starts}\: \Pi_{\mathsf{VTD}}.\mathsf{ForceOp}(C) \\
%    \<\< \mathsf{do}\: \mathsf{bal} \gets \mathsf{GetBal}(pk(01), \mathbb{A}) \\
%    \<\< \mathsf{while}\: \mathsf{bal} \neq \mathsf{swp(a)}\\
%    \< \sendmessageleft*{pk(1)} \< \\
%    (pk(10), sk(10)) \gets \Pi_{\mathsf{DS}}.\mathsf{KeyGen}(1^\lambda) \\
%    tx_\mathsf{swp} \gets \mathsf{InitTx}(pk(1), pk(10), \mathsf{swp(b)}, \mathbb{A}) \\
%    \< \sendmessage*{<->}{top={{\Gamma_{\mathsf{Swap}} \qquad \qquad \\ P_0 \xlongrightarrow{} (sk_0(01), tx_\mathsf{swp}) \\ (sk_1(01), sk(1)) \xlongleftarrow{} P_1 }}, bottom={lk := \sigma_{swp}(10) \oplus sk_0(01) \xlongrightarrow{} \\  \xlongleftarrow{} \sigma_{swp}(10) \qquad \qquad  }} \< \\
%    \mathsf{PubTx}(\sigma_{\mathsf{swp(10)}}, tx_\mathsf{frz}, \mathbb{A}) \\
%    \<\< \mathsf{do}\: \sigma_{swp}(10) \gets \mathsf{GetSig}(pk(1), \mathbb{B}) \\
%    \<\< \qquad sk(01) \gets (lk \oplus \sigma_{swp}(10)) + sk_1 \\
%    \<\< \qquad \sigma_{m} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}(sk(01), 1) \\
%    \<\< \mathsf{while}\: \Pi_{\mathsf{DS}}.\mathsf{Verify}(m, pk, \sigma_{m}) \neq 1 \\
%}
%\end{pchstack}
%\caption{Universal atomic swap protocol execution for a successful swap}
%\end{figure}
%

\subsubsection{Universal Atomic Swaps}

One of the first works proposing an atomic swap protocol that substitutes blockchain timelocks with a cryptographic primitive has been proposed by Thyagarajan et al. \cite{uas}, which utilizes Verifiable Timed Signatures (VTS) \cite{vts} as the core building block.

A VTS lets a user generate a timed commitment $C$ of a signature $\sigma$ on a message $m$ under a public key $\mathsf{pk}$. The commitment $C $ must hide the signature $\sigma$ for time $\mathsf{T}$. At the same time, the committer also generates a proof $\pi$ that proves that the commitment $C$ contains a valid signature $\sigma$. This guarantees that $\sigma$ can be publicly recovered in time $\mathsf{T}$ by anyone who solves the computational puzzle.

To give an intuition, imagine Alice and Bob sharing an address $\mathsf{pk_{ab}}$ where each party owns a share of the corresponding secret key.  Before sending the funds to $\mathsf{pk_{ab}}$, Alice and Bob sign a refund transaction $\mathsf{tx_{rfnd}}$ that transfers all funds from $\mathsf{pk_{ab}}$ back to Alice, in such a way that only Bob learns the signatures. Bob then generates a VTS on this refund signature and provides Alice the commitment $C$ and proof $\pi$. \\

Note that parties must account for potential differences in the computational power available for force opening the VTS commitments. This is to prevent scenarios where Alice or Bob with a powerful machine force opens its VTS commitments earlier than expected in terms of real time, resulting in being able 
to steal the coins of the other party during the swap lock or swap complete phase. In particular, the parties must ensure that $\Delta$ (such that T0 = T1 + $\Delta$) is large enough such that it tolerates the time differences to open the VTS commitments. \\

Parties are incentivized to make worst-case estimates for the counterparty's computational power which can be orders of magnitude faster when accounting for novel algorithms \cite{squaring_algo} and application-specific integrated circuits (ASIC) \cite{squaring_asic}. \\
This leads to an impractical protocol, as parties need to uninterruptedly compute a force opening for a significant amount of time.
\subsection{Contribution}

We propose an alternative construction of an universal atomic swap protocol which uses a single timelock $T$ for both parties. This approach eliminates the need to set a large $\Delta$ to mitigate potential differences in computation power. 
The protocol is asymmetric, with one party acting the client, who is required to compute a short timed commitment equivalent to the blockchain's confimation time, and the other party functioning as an exchange server, computing the commitment with timelock $T$,

We furthermore define a new interface to generalizes timed commitments independent of the specific construction.

\section{Preliminaries}

\todo[inline]{
Put the basic definitions here, e.g. signatures, hash functions, commitment, blockchains (maybe for this report just do it informally), etc.}

\subsection{Syntax definition}

\begin{itemize}[nosep, noitemsep] 
    \item $\mathbf{wait} \: \mathsf{fn}()$ - waits until the function $\mathsf{fn}()$ execution is complete. If $\mathsf{fn}()$ returns $\perp$, then it causes to abort the execution block returning $\perp$. \\
    \item $\mathbf{wait} \: \{...\}$ - enforces $\mathbf{wait}$ to all routines calls inside the block. If the block $\{...\}$ returns $\perp$, then it causes to abort the execution block returning $\perp$. Returns the value of the last evaluated routine. \\
    \item $\mathbf{select} \: \{...\}$ - concurrently runs all the $\mathbf{wait}$ routines in the block and returns the value of the first routine that successfully returns a value or $\perp$ if all the $\mathbf{wait}$ routines aborted with $\perp$. When a $\mathbf{wait}$ routine aborts returning $\perp$, it waits until execution of another $\mathbf{wait}$ is successfully completed. \\
\end{itemize}

In the protocol definition, variables and functions that are blockchain-specific (unless clear from context) are denoted with a subscript, example for a publick key on chain $\mathbb{B}$ we denote $\mathsf{pk_{(\mathbb{B})}}$. \\


\subsection{Blockchain interface}

We define the following oracles to interact with the blockchains. The subscript $\mathbb{A}$ indicates that we are interacting with chain $\mathbb{A}$.

\begin{itemize}[topsep=0pt, itemsep=0pt, leftmargin=2em]
    \item $\mathbf{0/1} \leftarrow \mathbf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{tx}}, \mathsf{tx})$: publish the transaction $\mathsf{tx}$ with signature $\sigma_{\mathsf{tx}}$. Outputs 1 if the transaction is accepted, 0 otherwise.
    \item $\mathbf{tx}_{\mathbb{A}} := (\mathsf{pk_{tx}}, \mathsf{pk_{rx}}, \mathsf{amnt}, \mathsf{id})  \leftarrow \mathbf{InitTx}_{(\mathbb{A})}(\mathsf{pk_{tx}}, \mathsf{pk_{rx}}, \mathsf{amnt})$: creates an unsigned transaction with the unique identifier $\mathsf{id}$ paying $\mathsf{amnt}$ from $\mathsf{pk_{tx}}$ to $\mathsf{pk_{rx}}$.
    \item $\mathbf{0/1} \leftarrow \mathbf{VerifyTx}_{(\mathbb{A})}(\sigma_{\mathsf{tx}}, \mathsf{tx})$: verifies the signature of the transaction and the validity of the transaction based on consensus rules. Outputs 1 if the verification succeeds, 0 otherwise.
    \item $\mathbf{0/1} \leftarrow \mathbf{WatchTx}_{(\mathbb{A})}(\mathsf{tx})$: wait for the transaction $\mathsf{tx}$ to be confirmed.
    \item $\mathbf{amnt} \leftarrow \mathbf{GetBal}_{(\mathbb{A})}(\mathsf{pk})$: get the balance of assets held by $\mathsf{pk}$
    \item $\mathbf{tx} \leftarrow \mathbf{GetLatestTx}_{(\mathbb{A})}(\mathsf{pk})$: get the the latest transaction of $\mathsf{pk}$'s record on the chain
    \item $\mathbf{ctx}_{\mathbb{A}} := (\mathsf{tx_{\mathbb{A}}}, C) \leftarrow \mathbf{CommitTx}_{(\mathbb{A})}(C, \mathsf{pk_{tx}}, \mathsf{pk_{rx}}, \mathsf{amnt}, \mathsf{t})$: creates an unsigned commit transaction paying $\mathsf{amnt}$ from $\mathsf{pk_{tx}}$ to $\mathsf{pk_{rx}}$ valid until block $\mathsf{t}$. The transaction can be later completed by opening and broadcasting $C$ through $\mathsf{RevTx}$
    \item $ \mathbf{0/1} \leftarrow \mathbf{RevTx}_{(\mathbb{A})}(\mathsf{sec}, \mathsf{tx})$: open the (on-chain) committed transaction $\mathsf{tx}$ by revealing the commited secret $\mathsf{sec}$
\end{itemize}

\subsection{Security definitions}

\textbf{Definition 1} (Atomicity): \textit{Either both parties successfully exchange each other's assets or neither party performs a successful swap.}
\vspace{0.5em}
\\
That is, after the protocol run there can be only two outcomes: \\
1) $P_0$ holds $\mathsf{amnt_b}$ on $\mathsf{pk_{swp(\mathbb{B})}}$ and $P_1$ holds $\mathsf{amnt_a}$ on $\mathsf{pk_{swp(\mathbb{A})}}$ (successful swap) \\
2) $P_0$ holds $\mathsf{amnt_a}$ on $\mathsf{pk_{init(\mathbb{A})}}$ and $P_1$ holds $\mathsf{amnt_b}$ on $\mathsf{pk_{init(\mathbb{B})}}$ or $\mathsf{pk_{rfnd(\mathbb{B})}}$ (swap aborted) \\

\textbf{Definition 2} (Ownership): \textit{All parties gain exclusive knowledge of the secret keys of their respective wallets holding the exchanged or refunded assets upon completion of the protocol.} 
\vspace{0.5em}
\\
That is after a successful protocol run $P_0$ owns $\mathsf{sk_{swp(\mathbb{B})}}$ and $P_1$ owns $\mathsf{sk_{swp(\mathbb{A})}}$, and respectively for the aborted swap  $\mathsf{sk_{init(\mathbb{A})}}$ and $\mathsf{sk_{init(\mathbb{B})}}$ or $\mathsf{sk_{rfnd(\mathbb{B})}}$. \\


\section{Atomic Swaps from Commit Transactions}

%\todo[inline]{For the current report, put a formal syntax, but maybe informal definitions of correctness and security. Especially, there should be an (informal) definition of commit transaction. }




%\todo[inline]{Set things up (e.g. let ... be a signature scheme, ... be a ... scheme. We construct a ... in Figure ...)}


\subsection{Version 0}

Parties $P_0$ and $P_1$ hold assets $a$ on blockchain $\mathbb{A}$ and assets $b$ on chain $\mathbb{B}$ respectively. \\
We define with $\mathsf{amnt_a}$ and $\mathsf{amnt_b}$ the amount of the assets the parties agreed to swap before starting the protocol.
%\textbf{Definition 1} (encrypted Verifiable Timed Discrelog) \\
%Public parameters $(\mathbb{G}, G, T)$ \\
%- $(eC, C, d, \pi) \gets \mathsf{Commit}(x, y, \textbf{T}$): the commit algorithm (randomized) takes as input a discrete log value $x \in \mathbb{Z}_q$, a hiding time $\textbf{T}$ and an encryption key $ y \in \mathbb{Z}_q$ and outputs a commitment $eC$ containing the encrypted puzzles, a commitment $C$ of $y$ with opening $d$ and a proof $\pi$. \\
%- $(0,1) \gets \mathsf{Verify}(H, eC, C, \pi)$: returns 1 if and only if the value $x$ embedded in $C$ decrypts $eC$ such that the value $y$ in decrypted $eC$ satisfies $H = G^y$  \\ \\
%- $(y, d) \gets \mathsf{ForceOp}(eC, x)$: the force open algorithm takes as input the encrypted commitment $eC$ and the encryption key $x$, outputs the committed value $y$ and the randomness $d$ used in generating $eC$

\[
    \mathcal{L}_{\mathsf{lock}} := \left\{\begin{array}{lr}  \mathsf{stmt} = (lk, y, h, \pi, T) : \exists (x) \:\: \text{s.t} \\
    (\mathcal{H}(x) = h \land \Pi_\mathsf{VTD}.\mathsf{Verify}(y, (lk \oplus x), \pi, T)) \end{array}\right\}
\]




\begin{figure}[H]
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (\mathbb{G}, [1], q, T, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    (\mathsf{sk_{frz0}}, \mathsf{pk_{frz}})_{(\mathbb{A})} \gets \mathsf{\textbf{wait}} \:\: \Gamma_{\mathsf{KeyGen}_{(\mathbb{A})}}(\mathbb{G}, [1], q) \\
    (C_0, \pi) \gets \mathsf{\textbf{wait}} \:\: \mathsf{receive}(P_1) \\
    \mathsf{\textbf{if}} \:\: \Pi_{\mathsf{VTD}}.\mathsf{Verify}([\mathsf{pk_{frz}}] - [\mathsf{sk_{frz0}}], C_0, \pi) \neq 1 \\
    \quad \mathsf{\textbf{return}} \perp \\
    \mathsf{res} \gets \mathsf{\textbf{select}} \:\: \{ \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \Pi_{\mathsf{VTD}}.\mathsf{ForceOp}(C_0) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad  (\mathsf{pk_{swp}}, \mathsf{sk_{swp}})_{(\mathbb{B})} \gets \Pi_{\mathsf{DS}}.\mathsf{KeyGen_{(\mathbb{B})}}(1^\lambda) \\
    \qquad \mathsf{tx_{frz(\mathbb{A})}} \gets \:\: \mathsf{InitTx}_{(\mathbb{A})}(\mathsf{pk_{init}}, \mathsf{pk_{frz}}, \mathsf{amnt_a}) \\
    \qquad \sigma_{\mathsf{frz(\mathbb{A})}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}_{(\mathbb{A})}(\mathsf{sk_{init}}, \mathsf{tx_{frz}}) \\
    \qquad \mathsf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{frz}}, \mathsf{tx_{frz}}) \\
    \qquad \mathsf{pk_{init(\mathbb{B})}} \gets  \mathsf{receive}(P_1) \\
    \qquad \mathsf{tx_{swp(\mathbb{B})}} \gets \mathsf{InitTx}_{(\mathbb{B})}(\mathsf{pk_{init}}, \mathsf{pk_{swp}}, \mathsf{amnt_b}) \\
    \qquad (C_1, \pi_1) \leftarrow \Pi_\mathsf{VTD}.\mathsf{Commit}(\mathsf{sk_{frz0}}, T_1) \\
    \qquad lk \leftarrow \mathsf{pk_{swp(\mathbb{B})}} \oplus C_1 \\
    \qquad \mathsf{hpk} \leftarrow \mathcal{H}(\mathsf{pk_{swp(\mathbb{B})}}) \\
    \qquad \pi_2 \leftarrow \Pi_{\mathsf{ZK}\mathcal{L}_{\mathsf{lock}}}.\mathsf{Pr}((lk, [\mathsf{sk_{frz0}}], \mathsf{hpk}, \pi_1, T_1), \mathsf{pk_{swp(\mathbb{B})}}) \\
    \qquad \mathsf{send}(P_1, \pi_1, \pi_2, \mathsf{hpk}, lk) \\
    \qquad \sigma_{\mathsf{swp(\mathbb{B})}} \gets \Gamma_{\mathsf{Swap}}(d, \mathsf{tx_{swp(\mathbb{B})}}) \\
    \qquad \textbf{if} \:\: \mathsf{VerifyTx}_{(\mathbb{B})}(\sigma_{\mathsf{swp}}, \mathsf{tx_{swp}}) \neq 1 \\
    \qquad \quad \mathsf{\textbf{return}} \perp \\
    \qquad \mathsf{PubTx}_{(\mathbb{B})}(\sigma_{\mathsf{swp}}, \mathsf{tx_{swp}}) \\
    \qquad \mathsf{send}(P_1) \\
    \quad \} \\
    \} \\
    \mathsf{\textbf{if}} \:\: \mathsf{res} \neq 1 \\
    \quad \mathsf{sk_{frz(\mathbb{A})}} := \mathsf{sk_{frz0}} + \mathsf{res} \\
    \quad \mathsf{tx_{rfnd(\mathbb{A})}} \gets \mathsf{\textbf{wait}} \:\: \mathsf{InitTx}_{(\mathbb{A})}(\mathsf{pk_{frz}}, \mathsf{pk_{init}}, \mathsf{amnt_a}) \\
    \quad \sigma_{\mathsf{rfnd(\mathbb{A})}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}_{(\mathbb{A})}(\mathsf{sk_{frz}}, \mathsf{tx_{rfnd}}) \\
    \quad \mathsf{\textbf{wait}} \:\: \mathsf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{rfnd}}, \mathsf{tx_{rfnd}}, \mathbb{A})
}
\end{pchstack}
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (\mathbb{G}, G, q, T, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    (\mathsf{sk_{frz1}}, \mathsf{pk_{frz}})_{(\mathbb{A})} \gets \mathsf{\textbf{wait}} \:\: \Gamma_{\mathsf{KeyGen}_{(\mathbb{A})}}(\mathbb{G}, [1], q) \\
    (C_0, \pi) \gets \Pi_{\mathsf{VTD}}.\mathsf{Commit}(\mathsf{sk_{frz1}}, T_1) \\
    \mathsf{send}(P_0,\: (C_0, \pi)) \\
    \mathsf{res} \gets \mathsf{\textbf{select}} \:\: \{ \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{timeout}(T/2) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{\textbf{do}} \:\: \mathsf{bal} \gets \mathsf{GetBal}_{(\mathbb{A})}(\mathsf{pk_{frz}}) \\
    \qquad \mathsf{\textbf{while}} \:\: \mathsf{bal} \neq {\mathsf{amnt_a}} \\
    \qquad \mathsf{send}(P_0,\: \mathsf{pk_{init}}) \\
    \qquad (\pi_1, \pi_2, \mathsf{hpk}, lk) \leftarrow \mathsf{receive}(P_0) \\
    \qquad \mathsf{\textbf{if}} \:\: \Pi_{\mathsf{ZK}\mathcal{L}_{\mathsf{lock}}}.\mathsf{Vr}((lk, \mathsf{pk_{frz}} - [\mathsf{sk_{frz1}}], \mathsf{hpk}, \pi_1, T_1), \pi_2) \neq 1 \\
    \qquad \quad \mathsf{\textbf{return}} \perp \\
    \qquad \Gamma_{\mathsf{Swap}}(\mathsf{hpk}, \mathsf{sk_{init(\mathbb{B})}}) \\
    \qquad \mathsf{receive}(P_0) \\
    \qquad \mathsf{tx_{swp(\mathbb{B})}} \leftarrow \mathsf{GetLatestTx}_{(\mathbb{A})}(\mathsf{pk}) \\
    \quad \} \\
    \} \\
    \mathsf{\textbf{if}} \:\: \mathsf{res} = 1 \\
    \quad \mathsf{pk_{swp(\mathbb{B})}} \leftarrow \mathsf{tx_{swp(\mathbb{B})}.rx} \\
    \quad C_1 \leftarrow (lk \oplus \mathsf{pk_{swp(\mathbb{B})}}, T_1) \\
    \quad \mathsf{sk_{frz0}} \leftarrow \Pi_\mathsf{VTD}.\mathsf{ForceOp}(C_1) \\
    \quad \mathsf{tx_{swp(\mathbb{A})}} \gets \mathsf{InitTx}_{(\mathbb{A})}(\mathsf{pk_{frz}}, \mathsf{pk_{swp}}, \mathsf{amnt_a}) \\
    \quad \sigma_{\mathsf{swp(\mathbb{A})}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}_{(\mathbb{A})}(\mathsf{sk_{frz0}} + \mathsf{sk_{frz1}}, \mathsf{tx_{rfnd}}) \\
    \quad \mathsf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{swp}}, \mathsf{tx_{swp}}) \\
    \mathsf{\textbf{else}} \\
    \quad  (\mathsf{pk_{rfnd}}, \mathsf{sk_{rfnd}}) \gets \Pi_{\mathsf{DS}}.\mathsf{KeyGen}_{(\mathbb{B})}(1^\lambda) \\
    \quad \mathsf{tx_{rfnd(\mathbb{B})}} \gets \mathsf{\textbf{wait}} \:\: \mathsf{InitTx}_{(\mathbb{B})}(\mathsf{pk_{init}}, \mathsf{pk_{rfnd}}, \mathsf{amnt_b}) \\
    \quad \sigma_{\mathsf{rfnd(\mathbb{B})}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}_{(\mathbb{B})}(\mathsf{sk_{init}}, \mathsf{tx_{rfnd}}) \\
    \quad \mathsf{\textbf{wait}} \:\: \mathsf{PubTx}{(\mathbb{B})}(\sigma_{\mathsf{rfnd}}, \mathsf{tx_{rfnd}})
}
\end{pchstack}
\end{minipage}%
\caption{Full protocol execution for $P_0$ and $P_1$, respectively left and right (alternative syntax)}
\end{figure}

\begin{figure}[H]
\begin{pchstack}[center, boxed]
\pseudocode{
    P_0(\mathsf{tx_{swp}}) \< \< P_1(\mathsf{hpk}, \mathsf{sk_{init(\mathbb{B})}}) \\[0.1\baselineskip ][\hline] 
    \<\< \\[-0.5\baselineskip ]
    \mathsf{\textbf{if}} \:\: \mathcal{H}(\mathsf{tx_{swp}}.rx) \neq \mathsf{hpk}) \\
    \qquad \mathsf{\textbf{return}} \perp \\
    \sigma_\mathsf{swp(\mathbb{B})} \leftarrow \Pi_{\mathsf{DS}}.\mathsf{Sign_{(\mathbb{B})}}(\mathsf{sk_{init}}, \mathsf{tx_{swp}})
}
\end{pchstack}
\caption{Protocol definition of 2PC $\Gamma_{\mathsf{Swap}}$}
\end{figure}

\subsection{Version 1}

Protocol version using commitment transaction with arbitrary value replacing VTD. \\

\begin{figure}[H]
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (\mathbb{G}, [1], q, T, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    \mathsf{sec} \gets \mathbb{Z}_q \\
    (C_0, r) \gets \Pi_{\mathsf{PCom}}.\mathsf{Commit}(\mathsf{sec_0}) \\ % verify that sec_0 has been commited
    \mathsf{ctx_{(\mathbb{A})}} \gets \mathsf{CommitTx}_{(\mathbb{A})}(C_0, \mathsf{pk_{init}}, \mathsf{pk_{swp}}, \mathsf{amnt_a}, T + \Delta) \\
    \sigma_{\mathsf{ctx_{(\mathbb{A})}}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}_{(\mathbb{A})}(\mathsf{sk_{init}}, \mathsf{ctx}) \\
    \mathsf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{ctx}}, \mathsf{ctx}) \\
    \mathsf{res} \gets \mathsf{\textbf{select}} \:\: \{ \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{timeout}(T) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{send}(\mathsf{ctx_{(\mathbb{A})}}) \\
    \qquad \mathsf{receive}(\mathsf{ctx_{(\mathbb{B})}}) \\
    \qquad \mathsf{res_1} \gets \mathsf{\textbf{wait}} \:\: \mathsf{WatchTx}_{(\mathbb{B})}(\mathsf{ctx}) \\
    \qquad \mathsf{\textbf{if}} \:\: \mathsf{ctx}_{(\mathbb{B})}.C \neq C_0 \lor \mathsf{ctx}_{(\mathbb{B})}.T \neq T \lor \mathsf{res_1} \neq 1 \\ % verify that commit transaction is valid and accepted
    \qquad \quad \mathsf{\textbf{return}} \perp \\
    \qquad \mathsf{rtx_{swp(\mathbb{B})}} \gets \mathsf{RevTx}_{(\mathbb{B})}(\mathsf{sec}, \mathsf{ctx}) \\
    \quad \} \\
    \} \\
}
\end{pchstack}
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (\mathbb{G}, [1], q, T, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    \mathsf{receive}(\mathsf{ctx_{(\mathbb{A})}}) \\
    \mathsf{res_0} \gets \mathsf{\textbf{wait}} \:\: \mathsf{WatchTx}_{(\mathbb{A})}(\mathsf{ctx}) \\
    \mathsf{res} \gets \mathsf{\textbf{select}} \:\: \{ \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{timeout}(T) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{\textbf{if}} \:\: \mathsf{ctx_{(\mathbb{A})}}.T \neq T + \Delta \lor \mathsf{res_0} \neq 1 \\ % verify that commit transaction is valid and accepted
    \qquad \quad \mathsf{\textbf{return}} \perp \\
    \qquad \mathsf{ctx}_{(\mathbb{B})} \gets \mathsf{CommitTx}_{(\mathbb{B})}(C_0, \mathsf{pk_{init}}, \mathsf{pk_{swp}}, \mathsf{amnt_b}, T) \\
    \qquad \mathsf{send}(\mathsf{ctx}_{(\mathbb{B})}) \\
    \qquad \mathsf{rtx_{swp(\mathbb{B})}} \gets \mathsf{\textbf{wait}} \:\: \mathsf{GetLatestTx}_{(\mathbb{B})}(\mathsf{pk_{swp}}) \\
    \qquad \mathsf{sec} := \mathsf{rtx_{swp(\mathbb{B})}}.\mathsf{rev} \\
    \qquad \mathsf{rtx_{swp(\mathbb{A})}} \gets \mathsf{RevTx}_{(\mathbb{A})}(\mathsf{sec}, \mathsf{ctx}) \\
    \quad \} \\
    \} \\
}
\end{pchstack}
\end{minipage}%
\caption{Full protocol execution for $P_0$ and $P_1$, respectively left and right (alternative syntax)}
\end{figure}


\section{Proof sketch}

\todo[inline]{Informal theorems for correctness and security and proof sketch}

We model the interaction in a zero trust setting: both parties are mutually distrusting and potentially malicious as they have an incentive to deceive the counter-party. \\
We further assume that a party cannot deny the counter-party from transacting on the blockchain.


\subsection{Party $P_0$}
We want to prove that $P_0$ at the end of a protocol run either holds $\mathsf{amnt_a}$ on $\mathsf{pk_{init(\mathbb{A})}}$ with exclusive knowledge of $\mathsf{sk_{init(\mathbb{A})}}$ or they hold $\mathsf{amnt_b}$ on $\mathsf{pk_{swp(\mathbb{B})}}$ with exclusive knowledge of $\mathsf{sk_{swp(\mathbb{B})}}$. \\


$P_0$ signs and publishes a transaction transferring $\mathsf{amnt_a}$ from $\mathsf{pk_{init(\mathbb{A})}}$ to the freeze wallet $\mathsf{pk_{frz(\mathbb{A})}}$ if and only if $\Pi_{\mathsf{VTD}}.\mathsf{Verify}(\mathsf{pk_{frz}} - [\mathsf{sk_{frz0}}], C_0, \pi_0) = 1$, thus by the soundess property of the VTD scheme $P_0$ is guaranteed of retrieving the commited diiscrete log value $x$ in $C_0$ that satisfies $[x] =  \mathsf{pk_{frz}} - [\mathsf{sk_{frz0}}]$ after $T$ steps. \\
Note that $\mathsf{pk_{frz}}$ has been generated in the 2PC protocol $\Gamma_{\mathsf{KeyGen}}$ with $\mathsf{pk_{frz}} := [\mathsf{sk_{frz0}} + \mathsf{sk_{frz1}}]$, hence we have $[x] = [\mathsf{sk_{frz0}} + \mathsf{sk_{frz1}}] - [\mathsf{sk_{frz0}}] = [\mathsf{sk_{frz1}}]$. \\

The party proceeds to concurrently executes two asynchronous $\textbf{wait}$ blocks, one performing $\Pi_{\mathsf{VTD}}.\mathsf{ForceOp}(C_0)$ and the other continuing the protocol execution. We note that from this point onwards, if any routine in the protocol execution timeouts or faults, $P_0$ will retrieve $\mathsf{sk_{frz0}}$ after $T_0$. \\
$P_0$ generates a new keypair $(\mathsf{pk_{swp}}, \mathsf{sk_{swp}})$ on $\mathbb{B}$, retrieves $\mathsf{pk_{init(\mathbb{B})}}$ from $P_1$ and  initialize the transaction $\mathsf{tx_{swp(\mathbb{B})}}$ transferring $\mathsf{amnt_b}$ from $\mathsf{pk_{init(\mathbb{B})}}$ to $\mathsf{pk_{swp(\mathbb{B})}}$.
They now proceed to commit their own secret share of $\mathsf{sk_{frz}}$ to $C_1$ with $\Pi_\mathsf{VTD}.\mathsf{Commit}(\mathsf{sk_{frz0}}, T_1)$ and generate a lock for the commitment $lk := C_1 \oplus \mathsf{pk_{swp(\mathbb{B})}}$, where $\mathsf{pk_{swp(\mathbb{B})}}$ is secret to $P_1$. \\
% They send the lock together with a proof of 
Note that $P_1$ gains no information about $\mathsf{pk_{swp(\mathbb{B})}}$ and thus can retrieve $C_1$ from $lk$ and force opening it only after $\mathsf{tx_{swp}}$ has been published by $P_0$. The privacy provery of the VTD scheme ensures that $P_1$ will retrieve $\mathsf{sk_{frz0}}$ only after time $T_1$, and since $T_1 \geq \mathbb{B}.\mathsf{ctime}$ $P_1$ will gain knowledge of $\mathsf{sk_{frz}}$ only after $P_0$ holds $\mathsf{amnt_b}$ on $\mathsf{pk_{swp(\mathbb{B})}}$.

Now assume instead that some routine in the protocol execution timed out or faulted, resulting in $\Pi_{\mathsf{VTD}}.\mathsf{ForceOp}(C_0)$ being solved: the party can retrieve $\mathsf{sk_{frz}}$ and they sign and publish $\mathsf{tx_{rfnd(\mathbb{A})}}$ transferring back $\mathsf{amnt_a}$ from $\mathsf{pk_{frz(\mathbb{A})}}$ to $\mathsf{pk_{init(\mathbb{A})}}$, thus resulting in $P_0$ holding $\mathsf{amnt_a}$ on $\mathsf{pk_{init(\mathbb{A})}}$.


\subsection{Party $P_1$}
After the protocol run either $P_1$ ends up with $\mathsf{amnt_a}$ on $\mathsf{pk_{swp(\mathbb{A})}}$ in case of a successful swap, with $\mathsf{amnt_b}$ on $\mathsf{pk_{rfnd(\mathbb{B})}}$ in case the swap was refunded or $\mathsf{amnt_b}$ on $\mathsf{pk_{init(\mathbb{B})}}$ if the swap was aborted. \\
We consider an active adversary over the communication channel with $P_0$ that can also corrupt $P_0$. We assume liveness and correctness for the blockchains.\\

Note that before calling $\Gamma_{\mathsf{Swap}}(\mathsf{sk_{frz1}}, \mathsf{sk_{init(\mathbb{B})}})$, $P_1$ is in control of their assets on $\mathsf{pk_{init(\mathbb{B})}}$ if it were to abort, and by general 2PC's privacy property both inputs are private. \\
Also note that $P_1$ waits until the funds $\mathsf{amnt_a}$ have been transferred to $\mathsf{pk_{frz}}$ before proceeding with  $\Gamma_{\mathsf{Swap}}$.
An adversary can only get the signature $\sigma_{swp(\mathbb{B})}$ if and only if it provided the correct $\mathsf{sk_{frz0}}$ and thus $P_1$ has received by correctness of 2PC $lk := \sigma_{swp(\mathbb{B})} \oplus \mathsf{sk_{frz0}}$. \\
If $P_1$ is unable to retrieve $\sigma_{swp(\mathbb{B})}$ before $T/2$, it proceeds to move the funds from $\mathsf{pk_{init}}$ to a newly generated $\mathsf{pk_{rfnd}}$, and thus an adversary holding $\sigma_{swp(\mathbb{B})}$ will be unable to get a transaction accepted by the correctness property of the blockchain (otherwise we occur in a double spending), so we end up with  $\mathsf{amnt_b}$ on $\mathsf{pk_{rfnd(\mathbb{B})}}$. \\
\\
If the transaction with signature $\sigma_{swp(\mathbb{B})}$ gets posted on $\mathbb{B}$, then $P_1$ will be able to retrieve $\mathsf{sk_{frz0}}$ by the above argument, and thus compute $\mathsf{sk_{frz}}$ and sign the swap transaction with it, ending up with $\mathsf{amnt_a}$ on $\mathsf{pk_{swp(\mathbb{A})}}$.


\section{Implementation and Evaluation}

\subsection{Implementation}

\todo[inline]{Write down note-worthy implementation details. At the very least, mention how building blocks are mentioned.}

\subsection{Performance Evaluation}

\todo[inline]{self explanatory}

\printbibliography


\end{document}
