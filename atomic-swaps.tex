\documentclass{article}      	% Style of the document                     
\usepackage{fullpage}
\usepackage{amsmath}     	   	% Maths                                          
\usepackage[utf8]{inputenc}	% UTF-8 characters                                               
\usepackage[T1]{fontenc}    	% Tuki ääkkösille (Finnish names don't cause problems)                                            
\usepackage{parskip}        		% Linebreak between paragraphs                
\usepackage{graphicx}       		% Graphics package for adding figures                        
\usepackage{epstopdf}       		% Possibility to add *.eps figures
 \usepackage{ dsfont }            % Symbol for real numbers
\usepackage{hyperref}
\usepackage{extarrows}
\usepackage{float}
\usepackage{makeidx}
\usepackage{enumitem}        % possibility to label list items by alphabet
\newcommand{\M}[1]{\ensuremath{\text{\texttt{#1}}}}
\usepackage[
    lambda,
    operators,
    advantage,
    sets,
    adversary,
    landau,
    probability,
    notions,
    logic,
    ff,
    mm,
    primitives,
    events,
    complexity,
    asymptotics,
    keys]{cryptocode}

\usepackage{todonotes}

 \usepackage{amsmath,amsfonts,graphicx,amssymb,amsthm}
\mathchardef\mhyphen="2D

 %% general
\mathchardef\mhyphen="2D
\newcommand{\fdv}{\mathcal{F}}
\newcommand{\tdv}{\mathcal{T}}
\newcommand{\vdv}{\mathcal{V}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\ID}{\mathcal{I}}
\newcommand{\bits}[1][]{\{0,1\}^{#1}}
\renewcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\mat}[1]{\mathbf{#1}}
\newcommand{\inner}[2]{\langle #1, #2 \rangle}
\newcommand{\transpose}{\mathtt{T}}
\newcommand{\round}[1]{\lfloor #1 \rceil}
\renewcommand{\dist}{\mathsf{dist}}
\renewcommand{\Pr}[2][]{{\text{Pr}_{#1}\left[#2\right]}}
\newcommand{\Exp}[2][]{{\mathbb{E}_{#1}\left[#2\right]}}
\newcommand{\mathcm}[2][1cm]{\hspace{#1}{\mbox{/\!\!/ } \text{\scriptsize#2}}}

%% lattice problems
\newcommand{\SIS}{\mathsf{SIS}}
\newcommand{\ISIS}{\mathsf{ISIS}}
\newcommand{\nfSIS}{\mathsf{nfSIS}}
\newcommand{\dSIS}{\mathsf{dSIS}}
\newcommand{\LWE}{\mathsf{LWE}}
\newcommand{\nfLWE}{\mathsf{nfLWE}}
\newcommand{\nfdLWE}{\mathsf{nfdLWE}}
\newcommand{\sLWE}{\mathsf{sLWE}}
\newcommand{\dLWE}{\mathsf{dLWE}}
\newcommand{\SVP}{\mathsf{SVP}}
\newcommand{\CVP}{\mathsf{CVP}}
\newcommand{\SIVP}{\mathsf{SIVP}}
\newcommand{\GapSVP}{\mathsf{GapSVP}}
\newcommand{\BDD}{\mathsf{BDD}}
\newcommand{\NTRU}{\mathsf{NTRU}}
\newcommand{\sNTRU}{\mathsf{sNTRU}}
\newcommand{\dNTRU}{\mathsf{dNTRU}}

%% lattice macros
\newcommand{\TT}{\mathbb{T}}
\newcommand{\ring}{\mathcal{R}}
\newcommand{\lattice}{\mathcal{L}}
\newcommand{\piped}{\mathcal{P}}
\newcommand{\ball}{\mathcal{B}}
\newcommand{\Hyb}{\mathsf{Hyb}}
\newcommand{\lspan}{\mathsf{span}}
\newcommand{\rank}{\mathsf{rank}}
\newcommand{\lsb}{\mathsf{LSB}}
\newcommand{\pubparam}{\mathsf{pp}}

%% group macros

%% syntax
\newcommand{\mpk}{\mathsf{mpk}}
\newcommand{\msk}{\mathsf{msk}}
\newcommand{\msg}{\mathsf{msg}}
\newcommand{\rnd}{\mathsf{rnd}}
\newcommand{\ctxt}{\mathsf{ctxt}}
\newcommand{\com}{\mathsf{com}}
\newcommand{\td}{\mathsf{td}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\stmt}{\mathsf{stmt}}
\newcommand{\wit}{\mathsf{wit}}
\newcommand{\tx}{\mathsf{tx}}
\newcommand{\aux}{\mathsf{aux}}
\newcommand{\ek}{\mathsf{ek}}

\newcommand{\Setup}{\mathsf{Setup}}
\newcommand{\Commit}{\mathsf{Com}}
\newcommand{\TrapGen}{\mathsf{TrapGen}}
\newcommand{\SampD}{\mathsf{SampD}}
\newcommand{\SampPre}{\mathsf{SampPre}}
\newcommand{\Prove}{\mathsf{Prove}}
\newcommand{\Verify}{\mathsf{Verify}}
\newcommand{\val}{\mathsf{val}}

%% primitive/scheme name
\newcommand{\PKE}{\mathsf{PKE}}
\newcommand{\LTDF}{\mathsf{LTDF}}
\newcommand{\rsagen}{\mathsf{RSAGen}}
\newcommand{\rsa}{\mathsf{RSA}}
\newcommand{\LHE}{\mathsf{LHE}}
\newcommand{\CS}{\mathcal{CS}}
\newcommand{\NTRUEncrypt}{\mathsf{NTRUEncrypt}}

%% others
\newcommand{\oracle}{\mathcal{O}}
\newcommand{\pcas}{~\mathbf{as}~}

\newcommand{\polylog}[1][\secpar]{\mathsf{polylog}(#1)}

\newcommand{\indrsidcpa}{\mathrm{IND\$}\mhyphen\mathrm{sID}\mhyphen\mathrm{CPA}}
%\newcommand{\oplus}{\, \texttt{XOR} \,} % shorthand for typing the XOR operator in mathmode

% feel free to add packages you need
% feel free to add packages you need

\begin{document}         
\author{Lorenzo Tucci}
\title{Atomic swaps}

\maketitle

\tableofcontents
\section{Introduction}

\todo[inline]{TODO starts}
\begin{itemize}
\item General description of problem (swapping), motivations, etc.
\item Introduce Universal Atomic Swaps (UAS) and its building blocks, briefly discuss how the protocol works, and highlight the issue of both parties needing to solve a VTS
\item The ``our contribution'' subsection: e.g. ``We propose an alternative construction ... we provide an open source implementation ...''
\item (Not so) Related work (subsection or section): Other ways to get atomic swaps, e.g. TEE, relays, HTLC, ...
\end{itemize}

\todo[inline]{TODO ends}

\subsection{Problem description}
Consider two ledgers $\mathbb{B}_a$ and $\mathbb{B}_b$. Alice holds assets $a$ in $\mathbb{B}_a$ and Bob holds assets beta in $\mathbb{B}_b$. We want to ensure that Alice transfers her assets $a$ in $\mathbb{B}_a$ to Bob if and only if Bob transfers his asset $b$ to Alice in $\mathbb{B}_b$.

There must be only two possible outcomes

1) Bob owns $a$ in $\mathbb{B}_a$ and Alice owns $b$ in $\mathbb{B}_b$ (swaps of assets)

2) Alice owns $a$ in $\mathbb{B}_a$ and Bob owns $b$ in $\mathbb{B}_b$ (assets refund)

Additionally, we want that the following properties hold: 

\textbf{Transparent}: an observer should not distinguish a transfer executed as part of an atomic swap from a standard transfer in such ledger. \\
\textbf{Trustless}: there are no trust assumption on any party executing the protocol. \\
\textbf{Scriptless}: the protocol does not require any script capabilities on both of the ledgers. \\

\section{Existing works}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Type} & \textbf{Trustless} & \textbf{Transparent} & \textbf{Scriptless} \\
\hline
TEE [BJZLZBDJ'17] & & \checkmark & \checkmark \\
\hline
HTLC [Gugger '20] & \checkmark & &\\
\hline
Relays [LMP'21] & \checkmark & &  \\
\hline
Universal [MTS'20] & \checkmark & \checkmark & \checkmark \\
\hline
\end{tabular}
\caption{Properties comparison of different atomic swaps protocol}
\end{table}
\subsection{TEE}
\subsection{Hashed Timelock Contract (HTLC)}

Closest solution to a universal protocol for atomic swaps, implemented by large majority of trustless exchange protocols. Using HTLC as building block, an atomic swap can be constructed as follows: Alice chooses r, computes h = H(r), transfers a into an HTLC$(a, h, t, A, B)$ in $\mathbb{B}_a$ and sends $h,t$ to Bob.

Bob cannot claim the HTLC yet because r is only known by Alice. Bob finishes the setup of the exchange by choosing a time $t' < t$ and transferring his $b$ assets into an HTLC$(b, h, t', b, a)$ in $\mathbb{B}_b$. Thus either

(1) Alice claims HTLC in $\mathbb{B}_b$, effectively revealing $r$ to Bob (and anyone observing $\mathbb{B}_b$) before $t'$. Bob can then use $r$ to claim the HTLC in $\mathbb{B}_a$;

(2) Alice does not claim HTLC in $\mathbb{B}_b$ and Bob cannot claim the HTLC in $\mathbb{B}_a$. After the timeout they get the funds back.

These cross-chain swaps are deployed in practice but have high execution costs and transactions sizes, in addition to following problems.

(1) Both ledgers must support compatible hash functions within their scripting language. In fact both should support the same hash function and each ledger must use the same number of bits to represent it. An observer can use the same h value at two ledgers and link HTLC as part of the same swap. Monero, Mimblewimble, Ripple, Stellar and Zcash do not support the computation of the HTLC contract

(2) Presence of timelock. Adding timelock functionality is at odds with privacy because (i) if implemented naively, makes time-locked transfers easy to distinguish from normal ones (ii) including it can conflict other privacy operations available in the ledger (iii) adds a non trivial overhead to computation and storage of the ledger if implemented correctly

(3) swap is restricted to only two HTLC, one per ledger, and thus to exchange of a assets in $\mathbb{B}_a$ and b assets in $\mathbb{B}_b$ (no multi coin swap).
\subsection{Relays}
Another strategy to achieve atomic swaps relies on relays. Relays are abstractions (in general a smart contract or a script) hosted on some
chain $\mathbb{B}_a$ that has light client like verification capabilities over chain $\mathbb{B}_b$. For each new block appended to chain $\mathbb{B}_a$,
the block header is passed on to the relay on chain $\mathbb{B}_b$. \\
The relay itself implements the standard verification procedure of chain $\mathbb{B}_a$’s consensus algorithm and can therefore verify the
validity of the block. Once the proof of work has been verified,
in the case of a Proof of Work (or PoW) blockchain, or the
two-thirds of validators signatures, in the case of a Byzantine
Fault Tolerant (or BFT) blockchain, it is possible to verify any
transaction of chain $\mathbb{B}_a$ from chain $\mathbb{B}_b$. With light client
like verification capabilities of chain $\mathbb{B}_a$ from chain $\mathbb{B}_b$,
we can imagine the following scenario. Bob has X assets of
chain $\mathbb{B}_b$. He is willing to exchange them for Y assets of
chain $\mathbb{B}_a$.  \\
    Bob sets up a smart contract SC1 and locks his
assets in it (1). This smart contract SC1 is set to release the
assets to anyone providing the proof that they made a payment
of Y assets of chain $\mathbb{B}_a$ to Bob’s address. Alice, who is
interested in this trade, transfers Y assets to Bob’s address (2).
She retrieves the transaction hash tx and provide it to SC1 (3).
SC1 calls the relay and asks for verification of transaction tx
(4). The relay verifies that the transfer has taken place and if
so, returns ok to SC1 (5). On receiving the answer from the
relay, SC1 transfers the X assets of $\mathbb{B}_b$ to Alice’s address.

\subsection{Verifiable Timed Signatures (VTS) / Universal Atomic Swaps}
The central challenge that the protocol needs to address is in ensuring atomicity of the swap even in the presence of malicious parties, which is guaranteed by the HTLC-based protocols. Drawing inspiration from that approach, an immediate barrier is the absence of scripting language does not allow to set “time-outs” on transactions.

A timeout $t$ for a transaction $\mathsf{tx}$ means that the transaction is accepted by the nodes in the network only after time $t$ has expired. Typically this is implemented by expressing $t$ in terms of a block number and leveraging a timelock script which is explicitly included in the transaction. \\

To simulate  such functionality without using any on-chain script, the main leverage will be VTS, which lets a user generate a timed commitment $C$ of a signature $\sigma$ on a message $m$ under a public key $\mathsf{pk}$. The commitment $C $ must hide the signature $\sigma$ for time $\mathsf{T}$. At the same time, the committer also generates a proof $\pi$ that proves that the commitment $C$ contains a valid signature $\sigma$. This guarantees that $\sigma$ can be publicly recovered in time $\mathsf{T}$ by anyone who solves the computational puzzle.

To give an intuition, imagine Alice and Bob sharing an address $\mathsf{pk}(ab)$ where each party owns a share of the corresponding secret key.  Before sending the funds to $\mathsf{pk}(ab)$, Alice and Bob sign a refund transaction $\mathsf{tx}(\mathsf{rfnd})$ that transfers all funds from $\mathsf{pk}(ab)$ back to Alice, in such a way that only Bob learns the signatures. Bob then generates a VTS on this refund signature and provides Alice the commitment $C$ and proof $\pi$. \\

Note that the parties must make conservative estimates of each other’s computational
power in force opening the VTD commitments. This is to
prevent scenarios where Alice or Bob with a powerful machine
force opens its VTD commitments earlier than expected in
terms of real time. The party could potentially steal the coins
of the other party during the swap lock or swap complete
phase. In particular, the parties must ensure that $\Delta$ (such that
T0 = T1 + $\Delta$) is large enough such that it tolerates the time
differences to open the VTD commitments.
%\begin{figure}[H]
%\begin{pchstack}[center, boxed]
%\pseudocode{
%    \textbf{$U_0(pk(0)\:, sk(0)$)} \< \< \textbf{$U_1(pk(1)\:, sk(1))$} \\[0.1\baselineskip ][\hline] 
%    \<\< \\[-0.5\baselineskip ]
%    \< \sendmessage*{<->}{top={{\Gamma_{\mathsf{KeyGen}}(\mathbb{G},G,q)}}, bottom={\xlongleftarrow{} (sk_0(01), pk(01)) \\ (sk_1(01), pk(01)) \xlongrightarrow{} }} \< \\
%    \<\< (C, \pi) \gets \Pi_{\mathsf{VTD}}.\mathsf{Commit}(sk_1, T) \\
%    \< \sendmessageleft*{(C, \pi)} \< \\
%    \mathsf{starts}\: \mathsf{Timeout}(T - \Delta)
%    \<\< \mathsf{starts}\: \mathsf{Timeout}(T - \Delta) \\
%    \mathsf{if}\: \Pi_{\mathsf{VTD}}.\mathsf{Verify}(pk, C, \pi) \neq 1 \\
%    \qquad \mathsf{abort}\\
%    tx_\mathsf{frz} \gets \mathsf{InitTx}(pk(0), pk(01), \mathsf{swp(a)}, \mathbb{A}) \\
%    \sigma_{\mathsf{frz}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}(sk(0), tx_\mathsf{frz}) \\
%    \mathsf{PubTx}(\sigma_{\mathsf{frz}}, tx_\mathsf{frz}, \mathbb{A}) \\
%    \mathsf{starts}\: \Pi_{\mathsf{VTD}}.\mathsf{ForceOp}(C) \\
%    \<\< \mathsf{do}\: \mathsf{bal} \gets \mathsf{GetBal}(pk(01), \mathbb{A}) \\
%    \<\< \mathsf{while}\: \mathsf{bal} \neq \mathsf{swp(a)}\\
%    \< \sendmessageleft*{pk(1)} \< \\
%    (pk(10), sk(10)) \gets \Pi_{\mathsf{DS}}.\mathsf{KeyGen}(1^\lambda) \\
%    tx_\mathsf{swp} \gets \mathsf{InitTx}(pk(1), pk(10), \mathsf{swp(b)}, \mathbb{A}) \\
%    \< \sendmessage*{<->}{top={{\Gamma_{\mathsf{Swap}} \qquad \qquad \\ U_0 \xlongrightarrow{} (sk_0(01), tx_\mathsf{swp}) \\ (sk_1(01), sk(1)) \xlongleftarrow{} U_1 }}, bottom={lk := \sigma_{swp}(10) \oplus sk_0(01) \xlongrightarrow{} \\  \xlongleftarrow{} \sigma_{swp}(10) \qquad \qquad  }} \< \\
%    \mathsf{PubTx}(\sigma_{\mathsf{swp(10)}}, tx_\mathsf{frz}, \mathbb{A}) \\
%    \<\< \mathsf{do}\: \sigma_{swp}(10) \gets \mathsf{GetSig}(pk(1), \mathbb{B}) \\
%    \<\< \qquad sk(01) \gets (lk \oplus \sigma_{swp}(10)) + sk_1 \\
%    \<\< \qquad \sigma_{m} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}(sk(01), 1) \\
%    \<\< \mathsf{while}\: \Pi_{\mathsf{DS}}.\mathsf{Verify}(m, pk, \sigma_{m}) \neq 1 \\
%}
%\end{pchstack}
%\caption{Universal atomic swap protocol execution for a successful swap}
%\end{figure}
%

\section{Preliminaries}

\todo[inline]{
Put the basic definitions here, e.g. signatures, hash functions, commitment, blockchains (maybe for this report just do it informally), etc.}

\section{Atomic Swaps from Commit Transactions}

\todo[inline]{For the current report, put a formal syntax, but maybe informal definitions of correctness and security. Especially, there should be an (informal) definition of commit transaction. }


\section{Protocol improvement proposal}

\todo[inline]{Set things up (e.g. let ... be a signature scheme, ... be a ... scheme. We construct a ... in Figure ...)}

Parties $U_0$ and $U_1$ hold assets $a$ on blockchain $\mathbb{A}$ and assets $b$ on chain $\mathbb{B}$ respectively. \\
We define with $\mathsf{amnt_a}$ and $\mathsf{amnt_b}$ the amount of the assets the parties agreed to swap before starting the protocol. \\
In the protocol definition, variables and functions that are blockchain-specific (unless clear from context) are denoted with a subscript, example for a publick key on chain $\mathbb{B}$ we denote $\mathsf{pk_{(\mathbb{B})}}$. \\
\\

Informally, we want the atomicity security property: parties should either both end up with the original funds in a wallet they own (refund case) or they should own the agreed assets to swap on their respective target wallets. \\

We define the following oracles to interact with the blockchains.

- $\mathsf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{tx}}, \mathsf{tx})$ publish the transaction $\mathsf{tx}$ with signature $\sigma_{\mathsf{tx}}$ on chain $\mathbb{A}$ \\
- $\mathsf{InitTx}_{(\mathbb{A})}(\mathsf{pk_{tx}}, \mathsf{pk_{rx}}, \mathsf{amnt})$ create an unsigned transaction paying $\mathsf{amnt}$ from $\mathsf{pk_{tx}}$ to $\mathsf{pk_{rx}}$ on chain $\mathbb{A}$ \\
- $\mathsf{WatchTx}_{(\mathbb{A})}(\mathsf{tx})$ wait for the transaction $\mathsf{tx}$ to be confirmed on chain $\mathbb{A}$ \\
- $\mathsf{GetBal}_{(\mathbb{A})}(\mathsf{pk})$ get the balance of assets held by $\mathsf{pk}$ \\
- $\mathsf{GetSig}_{(\mathbb{A})}(\mathsf{pk})$ get the signature $\sigma_{\mathsf{tx}}$ of the latest transaction in $\mathsf{pk}$'s record on chain $\mathbb{A}$ \\

$U_1$ starts counting the timeout from the moment they send the $\mathsf{VTD}$ commitment to $U_0$, and respectively $U_0$ starts counting down from the moment they receive it. \\
\\


\begin{figure}[H]
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (\mathbb{G}, [1], q, T, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    (\mathsf{sk_{frz0}}, \mathsf{pk_{frz}}) \gets \mathsf{\textbf{wait}} \:\: \Gamma_{\mathsf{KeyGen}_{(\mathbb{A})}}(\mathbb{G}, [1], q) \\
    (C, \pi) \gets \mathsf{\textbf{wait}} \:\: \mathsf{receive}(U_1) \\
    \mathsf{\textbf{if}} \:\: \Pi_{\mathsf{VTD}}.\mathsf{Verify}([\mathsf{pk_{frz}}] - [\mathsf{sk_{frz0}}], C, \pi) \neq 1 \\
    \quad \mathsf{\textbf{return}} \perp \\
    \mathsf{res} \gets \mathsf{\textbf{select}} \:\: \{ \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \Pi_{\mathsf{VTD}}.\mathsf{ForceOp}(C) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
	\qquad  (\mathsf{pk_{swp}}, \mathsf{sk_{swp}}) \gets \Pi_{\mathsf{DS}}.\mathsf{KeyGen_{(\mathbb{B})}}(1^\lambda) \\
    \qquad \mathsf{tx_{frz}} \gets \:\: \mathsf{InitTx}_{(\mathbb{A})}(\mathsf{pk_{init}}, \mathsf{pk_{frz}}, \mathsf{amnt_a}) \\
    \qquad \sigma_{\mathsf{frz}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}_{(\mathbb{A})}(\mathsf{sk_{init}}, \mathsf{tx_{frz}}) \\
    \qquad \mathsf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{frz}}, \mathsf{tx_{frz}}) \\
    \qquad \mathsf{pk_{init(\mathbb{B})}} \gets  \mathsf{receive}(U_1) \\
    \qquad \mathsf{tx_{swp}} \gets \mathsf{InitTx}_{(\mathbb{B})}(\mathsf{pk_{init}}, \mathsf{pk_{swp}}, \mathsf{amnt_b}) \\
    \qquad \sigma_{\mathsf{swp(\mathbb{B})}} \gets \Gamma_{\mathsf{Swap}}(\mathsf{sk_{frz0}}, \mathsf{tx_{swp}}) \\
    \qquad \mathsf{PubTx}_{(\mathbb{B})}(\sigma_{\mathsf{swp}}, \mathsf{tx_{swp}}) \\
    \qquad \mathsf{send}(U_1) \\
    \quad \} \\
    \} \\
    \mathsf{\textbf{if}} \:\: \mathsf{res} \neq 1 \\
    \quad \mathsf{sk_{frz}} := \mathsf{sk_{frz0}} + \mathsf{res} \\
    \quad \mathsf{tx_{rfnd}} \gets \mathsf{\textbf{wait}} \:\: \mathsf{InitTx}_{(\mathbb{A})}(\mathsf{pk_{frz}}, \mathsf{pk_{init}}, \mathsf{amnt_a}) \\
    \quad \sigma_{\mathsf{rfnd}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}_{(\mathbb{A})}(\mathsf{sk_{frz}}, \mathsf{tx_{rfnd}}) \\
    \quad \mathsf{\textbf{wait}} \:\: \mathsf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{rfnd}}, \mathsf{tx_{rfnd}}, \mathbb{A})
}
\end{pchstack}
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (\mathbb{G}, G, q, T, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    (\mathsf{sk_{frz1}}, \mathsf{pk_{frz}}) \gets \mathsf{\textbf{wait}} \:\: \Gamma_{\mathsf{KeyGen}_{(\mathbb{A})}}(\mathbb{G}, [1], q) \\
    (C, \pi) \gets \Pi_{\mathsf{VTD}}.\mathsf{Commit}(\mathsf{sk_{frz1}}, T) \\
    \mathsf{send}(U_0,\: (C, \pi)) \\
    \mathsf{res} \gets \mathsf{\textbf{select}} \:\: \{ \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{timeout}(T/2) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{\textbf{do}} \:\: \mathsf{bal} \gets \mathsf{GetBal}_{(\mathbb{A})}(\mathsf{pk_{frz}}) \\
    \qquad \mathsf{\textbf{while}} \:\: \mathsf{bal} \neq {\mathsf{amnt_a}} \\
    \qquad \mathsf{send}(U_1,\: \mathsf{pk_{init}}) \\
    \qquad lk \gets \Gamma_{\mathsf{Swap}}(\mathsf{sk_{frz1}}, \mathsf{sk_{init(\mathbb{B})}}) \\
    \qquad \mathsf{receive}(U_0) \\
    \qquad \mathsf{\sigma_{lk}} \gets \mathsf{GetSig}_{(\mathbb{B})}(\mathsf{pk_{init}}) \\
    \qquad \mathsf{sk_{frz}} \gets (lk \oplus \sigma_{lk}) + \mathsf{sk_{frz1}} \\
    \qquad \mathsf{tx_{swp}} \gets \mathsf{InitTx}_{(\mathbb{A})}(\mathsf{pk_{frz}}, \mathsf{pk_{swp}}, \mathsf{amnt_a}) \\
    \qquad \sigma_{\mathsf{swp}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}_{(\mathbb{A})}(\mathsf{sk_{frz}}, \mathsf{tx_{rfnd}}) \\
    \qquad \mathsf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{swp}}, \mathsf{tx_{swp}}) \\
    \quad \} \\
    \} \\
    \mathsf{\textbf{if}} \:\: \mathsf{res} \neq 1 \land lk \neq \perp \\
    \quad  (\mathsf{pk_{rfnd}}, \mathsf{sk_{rfnd}}) \gets \Pi_{\mathsf{DS}}.\mathsf{KeyGen}_{(\mathbb{B})}(1^\lambda) \\
    \quad \mathsf{tx_{rfnd}} \gets \mathsf{\textbf{wait}} \:\: \mathsf{InitTx}_{(\mathbb{B})}(\mathsf{pk_{init}}, \mathsf{pk_{rfnd}}, \mathsf{amnt_b}) \\
    \quad \sigma_{\mathsf{rfnd}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}_{(\mathbb{B})}(\mathsf{sk_{init}}, \mathsf{tx_{rfnd}}) \\
    \quad \mathsf{\textbf{wait}} \:\: \mathsf{PubTx}{(\mathbb{B})}(\sigma_{\mathsf{rfnd}}, \mathsf{tx_{rfnd}})
}
\end{pchstack}
\end{minipage}%
\caption{Full protocol execution for $U_0$ and $U_1$, respectively left and right (alternative syntax)}
\end{figure}

\section{Proof sketch}

\todo[inline]{Informal theorems for correctness and security and proof sketch}

\subsection{Party $U_0$}

Informally, we want that the atomic property holds: after the protocol run either $U_0$ ends up with $\mathsf{amnt_b}$ on $\mathsf{pk_{swp(\mathbb{B})}}$ in case of a successful swap or with $\mathsf{amnt_a}$ on $\mathsf{pk_{init(\mathbb{A})}}$, in case the swap was aborted or refunded.  \\
We consider an active adversary over the communication channel with $U_1$ that can also corrupt $U_1$. We assume liveness and correctness for the blockchains.\\

By general 2PC's privacy property, $\mathsf{sk_{frz1}}$ is only known to $U_0$. \\
By the $\Pi_{\mathsf{VTD}}.\mathsf{Verify}$ algorithm we have that $\Pi_{\mathsf{VTD}}.\mathsf{Verify}(\mathsf{pk_{frz}} - [\mathsf{sk_{frz0}}], C, \pi) = 1$ if and only if the value embedded $x$ in the commitmemt $C$ satisfies $[x] =  \mathsf{pk_{frz}} - [\mathsf{sk_{frz0}}]$. \\
Assuming a group based $\Pi_{\mathsf{DS}}$ with $\mathsf{pk} := [\mathsf{sk}]$, we have that $\mathsf{sk_{frz}} := \mathsf{sk_{frz0}} + \mathsf{sk_{frz1}}$ and thus $[\mathsf{sk_{frz0}} + \mathsf{sk_{frz1}}] - [\mathsf{sk_{frz0}}] = [\mathsf{sk_{frz1}}] = [x] $. Hence $U_0$ proceeds to swap the assets if and only if the value committed in $C$ is $\mathsf{sk_{frz1}}$ and $\mathsf{pk_{frz}} = [\mathsf{sk_{frz0}} + \mathsf{sk_{frz1}}]$.   \\
Note that by the $\mathsf{VTD}$'s soundness property the $\mathsf{ForceOp}$ algorithm will produce the committed dlog value $x$ in time $\textbf{T}$, thus $U_0$ will be able to retrieve  $\mathsf{sk_{frz1}}$ after time $T$ and sign a refund transaction. \\
Now $U_0$ transfer the funds to $\mathsf{pk_{frz}}$ and proceeds to generate a new keypair $(\mathsf{pk_{swp}}, \mathsf{sk_{swp}})$ secret to the outside world. \\
When calling the 2PC protocol $\Gamma_{\mathsf{Swap}}(\mathsf{sk_{frz0}}, \mathsf{tx_{swp}})$, note that the inputs are again secret by 2PC's privacy property. \\
If $\sigma_{\mathsf{swp(\mathbb{B})}}$ is invalid, $\mathsf{PubTx}_{(\mathbb{B})}(\sigma_{\mathsf{swp}}, \mathsf{tx_{swp}})$ will fail and $U_0$ will wait until $\mathsf{ForceOp}$ completes to compute $\mathsf{sk_{frz}}$ and sign the refund transaction with it, ending up with $\mathsf{amnt_a}$ on $\mathsf{pk_{init(\mathbb{A})}}$. \\
Otherwise, the swap will complete successfully, and $U_0$ ends up with $\mathsf{amnt_b}$ on $\mathsf{pk_{swp(\mathbb{B})}}$. \\
An adversary has no information about $\mathsf{sk_{frz0}}$ and $(\mathsf{pk_{swp}}, \mathsf{sk_{swp}})$, thus it cannot sign transaction from $\mathsf{pk_{frz}}$ or compute a valid signature for $\mathsf{pk_{swp}}$, and is thus unable to retrieve information about $\mathsf{sk_{frz0}}$ from $lk$.\\

\subsection{Party $U_1$}
After the protocol run either $U_1$ ends up with $\mathsf{amnt_a}$ on $\mathsf{pk_{swp(\mathbb{A})}}$ in case of a successful swap, with $\mathsf{amnt_b}$ on $\mathsf{pk_{rfnd(\mathbb{B})}}$ in case the swap was refunded or $\mathsf{amnt_b}$ on $\mathsf{pk_{init(\mathbb{B})}}$ if the swap was aborted. \\
We consider an active adversary over the communication channel with $U_0$ that can also corrupt $U_0$. We assume liveness and correctness for the blockchains.\\

Note that before calling $\Gamma_{\mathsf{Swap}}(\mathsf{sk_{frz1}}, \mathsf{sk_{init(\mathbb{B})}})$, $U_1$ is in control of their assets on $\mathsf{pk_{init(\mathbb{B})}}$ if it were to abort, and by general 2PC's privacy property both inputs are private. \\
Also note that $U_1$ waits until the funds $\mathsf{amnt_a}$ have been transferred to $\mathsf{pk_{frz}}$ before proceeding with  $\Gamma_{\mathsf{Swap}}$.
An adversary can only get the signature $\sigma_{swp(\mathbb{B})}$ if and only if it provided the correct $\mathsf{sk_{frz0}}$ and thus $U_1$ has received by correctness of 2PC $lk := \sigma_{swp(\mathbb{B})} \oplus \mathsf{sk_{frz0}}$. \\
If $U_1$ is unable to retrieve $\sigma_{swp(\mathbb{B})}$ before $T/2$, it proceeds to move the funds from $\mathsf{pk_{init}}$ to a newly generated $\mathsf{pk_{rfnd}}$, and thus an adversary holding $\sigma_{swp(\mathbb{B})}$ will be unable to get a transaction accepted by the correctness property of the blockchain (otherwise we occur in a double spending), so we end up with  $\mathsf{amnt_b}$ on $\mathsf{pk_{rfnd(\mathbb{B})}}$. \\
\\
If the transaction with signature $\sigma_{swp(\mathbb{B})}$ gets posted on $\mathbb{B}$, then $U_1$ will be able to retrieve $\mathsf{sk_{frz0}}$ by the above argument, and thus compute $\mathsf{sk_{frz}}$ and sign the swap transaction with it, ending up with $\mathsf{amnt_a}$ on $\mathsf{pk_{swp(\mathbb{A})}}$.

\newpage
\begin{figure}[H]
\begin{pchstack}[center, boxed]

\pseudocode{
    \textbf{$U_0(pk(0)\:, sk(0)$)} \< \< \textbf{$U_1(pk(1)\:, sk(1))$} \\[0.1\baselineskip ][\hline] 
    \<\< \\[-0.5\baselineskip ]
    sk(01) := sk_0(01) + sk_1(01) \\
    \sigma_{swp}(10) \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}(sk(1), tx_\mathsf{swp}) \\
    lk := \sigma_{swp}(10) \oplus sk_0(01) \\
}
\end{pchstack}
\caption{Protocol definition of 2PC $\Gamma_{\mathsf{Swap}}$}
\end{figure}

\section{Implementation and Evaluation}

\subsection{Implementation}

\todo[inline]{Write down note-worthy implementation details. At the very least, mention how building blocks are mentioned.}

\subsection{Performance Evaluation}

\todo[inline]{self explanatory}


\end{document}
