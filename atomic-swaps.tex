\documentclass{article}      	% Style of the document                     
\usepackage{fullpage}
\usepackage{amsmath}     	   	% Maths                                          
\usepackage[utf8]{inputenc}	% UTF-8 characters                                               
\usepackage[T1]{fontenc}    	% Tuki ääkkösille (Finnish names don't cause problems)                                            
\usepackage{parskip}        		% Linebreak between paragraphs                
\usepackage{graphicx}       		% Graphics package for adding figures                        
\usepackage{epstopdf}       		% Possibility to add *.eps figures
 \usepackage{ dsfont }            % Symbol for real numbers
\usepackage{hyperref}
\usepackage{extarrows}
\usepackage{float}
\usepackage{makeidx}
\usepackage{enumitem}        % possibility to label list items by alphabet
\newcommand{\M}[1]{\ensuremath{\text{\texttt{#1}}}}
\usepackage[
    lambda,
    operators,
    advantage,
    sets,
    adversary,
    landau,
    probability,
    notions,
    logic,
    ff,
    mm,
    primitives,
    events,
    complexity,
    asymptotics,
    keys]{cryptocode}

\usepackage{todonotes}

 \usepackage{amsmath,amsfonts,graphicx,amssymb,amsthm}
\mathchardef\mhyphen="2D

 %% general
\mathchardef\mhyphen="2D
\newcommand{\fdv}{\mathcal{F}}
\newcommand{\tdv}{\mathcal{T}}
\newcommand{\vdv}{\mathcal{V}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\ID}{\mathcal{I}}
\newcommand{\bits}[1][]{\{0,1\}^{#1}}
\renewcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\mat}[1]{\mathbf{#1}}
\newcommand{\inner}[2]{\langle #1, #2 \rangle}
\newcommand{\transpose}{\mathtt{T}}
\newcommand{\round}[1]{\lfloor #1 \rceil}
\renewcommand{\dist}{\mathsf{dist}}
\renewcommand{\Pr}[2][]{{\text{Pr}_{#1}\left[#2\right]}}
\newcommand{\Exp}[2][]{{\mathbb{E}_{#1}\left[#2\right]}}
\newcommand{\mathcm}[2][1cm]{\hspace{#1}{\mbox{/\!\!/ } \text{\scriptsize#2}}}

%% lattice problems
\newcommand{\SIS}{\mathsf{SIS}}
\newcommand{\ISIS}{\mathsf{ISIS}}
\newcommand{\nfSIS}{\mathsf{nfSIS}}
\newcommand{\dSIS}{\mathsf{dSIS}}
\newcommand{\LWE}{\mathsf{LWE}}
\newcommand{\nfLWE}{\mathsf{nfLWE}}
\newcommand{\nfdLWE}{\mathsf{nfdLWE}}
\newcommand{\sLWE}{\mathsf{sLWE}}
\newcommand{\dLWE}{\mathsf{dLWE}}
\newcommand{\SVP}{\mathsf{SVP}}
\newcommand{\CVP}{\mathsf{CVP}}
\newcommand{\SIVP}{\mathsf{SIVP}}
\newcommand{\GapSVP}{\mathsf{GapSVP}}
\newcommand{\BDD}{\mathsf{BDD}}
\newcommand{\NTRU}{\mathsf{NTRU}}
\newcommand{\sNTRU}{\mathsf{sNTRU}}
\newcommand{\dNTRU}{\mathsf{dNTRU}}

%% lattice macros
\newcommand{\TT}{\mathbb{T}}
\newcommand{\ring}{\mathcal{R}}
\newcommand{\lattice}{\mathcal{L}}
\newcommand{\piped}{\mathcal{P}}
\newcommand{\ball}{\mathcal{B}}
\newcommand{\Hyb}{\mathsf{Hyb}}
\newcommand{\lspan}{\mathsf{span}}
\newcommand{\rank}{\mathsf{rank}}
\newcommand{\lsb}{\mathsf{LSB}}
\newcommand{\pubparam}{\mathsf{pp}}

%% group macros

%% syntax
\newcommand{\mpk}{\mathsf{mpk}}
\newcommand{\msk}{\mathsf{msk}}
\newcommand{\msg}{\mathsf{msg}}
\newcommand{\rnd}{\mathsf{rnd}}
\newcommand{\ctxt}{\mathsf{ctxt}}
\newcommand{\com}{\mathsf{com}}
\newcommand{\td}{\mathsf{td}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\stmt}{\mathsf{stmt}}
\newcommand{\wit}{\mathsf{wit}}
\newcommand{\tx}{\mathsf{tx}}
\newcommand{\aux}{\mathsf{aux}}
\newcommand{\ek}{\mathsf{ek}}

\newcommand{\Setup}{\mathsf{Setup}}
\newcommand{\Commit}{\mathsf{Com}}
\newcommand{\TrapGen}{\mathsf{TrapGen}}
\newcommand{\SampD}{\mathsf{SampD}}
\newcommand{\SampPre}{\mathsf{SampPre}}
\newcommand{\Prove}{\mathsf{Prove}}
\newcommand{\Verify}{\mathsf{Verify}}
\newcommand{\val}{\mathsf{val}}

%% primitive/scheme name
\newcommand{\PKE}{\mathsf{PKE}}
\newcommand{\LTDF}{\mathsf{LTDF}}
\newcommand{\rsagen}{\mathsf{RSAGen}}
\newcommand{\rsa}{\mathsf{RSA}}
\newcommand{\LHE}{\mathsf{LHE}}
\newcommand{\CS}{\mathcal{CS}}
\newcommand{\NTRUEncrypt}{\mathsf{NTRUEncrypt}}

%% others
\newcommand{\oracle}{\mathcal{O}}
\newcommand{\pcas}{~\mathbf{as}~}

\newcommand{\polylog}[1][\secpar]{\mathsf{polylog}(#1)}

\newcommand{\indrsidcpa}{\mathrm{IND\$}\mhyphen\mathrm{sID}\mhyphen\mathrm{CPA}}
%\newcommand{\oplus}{\, \texttt{XOR} \,} % shorthand for typing the XOR operator in mathmode


\usepackage{biblatex}
\addbibresource{references.bib}

\begin{document}         
\author{Lorenzo Tucci}
\title{Atomic swaps}

\maketitle

\tableofcontents
\section{Introduction}

An atomic swap cross-chain swap is an exchange of assets held at two different blockchains between two users without any additional trust assumption. \\
Consider two ledgers $\mathbb{A}$ and $\mathbb{B}$, where Alice holds assets $a$ in $\mathbb{A}$ and Bob holds assets beta in $\mathbb{B}$. We want to ensure that Alice transfers her assets $a$ in $\mathbb{B}_a$ to Bob if and only if Bob transfers his asset $b$ to Alice in $\mathbb{B}_b$. \\

The word \textit{atomic} implies that the protocol execution can only have two possible outcomes: \\
1) the asset swap is successful, with Bob owning $a$ in $\mathbb{A}$ and Alice owning $b$ in $\mathbb{B}$ \\
2) the swap aborts with an asset refund, so Alice owns $a$ in $\mathbb{A}$ and Bob owns $b$ in $\mathbb{B}$ \\


\todo[inline]{TODO starts}
\begin{itemize}
\item General description of problem (swapping), motivations, etc.
\item Introduce Universal Atomic Swaps (UAS) and its building blocks, briefly discuss how the protocol works, and highlight the issue of both parties needing to solve a VTS
\item The ``our contribution'' subsection: e.g. ``We propose an alternative construction ... we provide an open source implementation ...''
\item (Not so) Related work (subsection or section): Other ways to get atomic swaps, e.g. TEE, relays, HTLC, ...
\end{itemize}

\todo[inline]{TODO ends}

\subsection{Existing solutions}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Type} & \textbf{Trustless} & \textbf{Transparent} & \textbf{Scriptless} \\
\hline
TEE [BJZLZBDJ'17] & & \checkmark & \checkmark \\
\hline
HTLC [Gugger '20] & \checkmark & &\\
\hline
Relays [LMP'21] & \checkmark & &  \\
\hline
Universal [MTS'20] & \checkmark & \checkmark & \checkmark \\
\hline
\end{tabular}
\caption{Properties comparison of different atomic swaps protocol}
\end{table}
\subsubsection{Hashed Timelock Contract (HTLC)}

Using a blockchain's scripting language and timelock functionalities it is possible to create a script that functions as a timed escrow that can be claimed if some condition is satisfied or refunded when expired. \\
More specifically, a hash-time lock contract (HTLC) has on input a tuple $(\mathsf{amnt_a}, h, T, \mathsf{pk_0}, \mathsf{pk_1})$ where $\mathsf{amnt_a}$ denotes the amount of $\mathsf{a}$ assets to be exchanged, $h$ is a hash value, $T$ the timeout, $\mathsf{pk_0}$ and $\mathsf{pk_1}$ the public key addresses of
two users, the HTLC transfers $\mathsf{amnt_a}$ to $\mathsf{pk_1}$ if invoked before timeout $T$ with input value $r$ such that $\mathcal{H}(r) = h$. 
If the contract is invoked after timeout $T$, it refunds the assets $\mathsf{amnt_a}$ to $\mathsf{pk_0}$ unconditionally. \\

Using HTLCs as a building block, an atomic swap protocol can be constructed as follows: \\
Alice chooses $r$, computes $h = \mathcal{H}(r)$, transfers $\mathsf{amnt_a}$ into an $(\mathsf{amnt_a}, h, T_0, \mathsf{pk_0}, \mathsf{pk_1})$ on blockchain $\mathbb{A}$ and sends $h,T$ to Bob. \\
Bob finishes the setup of the exchange by choosing a time $T_1 < T_0$ and transferring his $\mathsf{amnt_b}$ assets into an HTLC$(\mathsf{amnt_b}, h, T_1, \mathsf{pk_1}, \mathsf{pk_0})$ on blockchain $\mathbb{B}$. We note that Bob cannot claim the HTLC yet as $r$ is only known by Alice, thus there are only two possible outcomes: \\

(1) Alice claims the HTLC on $\mathbb{B}$ before $T_0$, effectively revealing $r$ to bob (and anyone observing $\mathbb{B}$), Bob can then proceed to compute $h = \mathcal{H}(r)$ to claim the counterpart HTLC on chain $\mathbb{A}$ \\
(2) Alice does not claim the HTLC on $\mathbb{B}$ in time and thus Bob cannot claim the HTLC on $\mathbb{A}$. After the respective timeouts they can refund the assets by invoking the contracts.

We note that this functionality can be realized without requiring complex scripting functionality \cite{h4sh3d} using semi-scriptless scripts. \\
A slightly different protocol can also be realized even if only one blockchain supports HTLCs or timelocks, as done in \cite{h4sh3d} for the Monero counterpart.
\todo[inline]{explain (splitting secret key, BTC party needs to move first)}

%\subsubsection{Relays}
%Another strategy to achieve atomic swaps relies on relays. Relays are abstractions (in general a smart contract or a script) hosted on some
%chain $\mathbb{B}_a$ that has light client like verification capabilities over chain $\mathbb{B}_b$. For each new block appended to chain $\mathbb{B}_a$,
%the block header is passed on to the relay on chain $\mathbb{B}_b$. \\
%The relay itself implements the standard verification procedure of chain $\mathbb{B}_a$’s consensus algorithm and can therefore verify the
%validity of the block. Once the proof of work has been verified,
%in the case of a Proof of Work (or PoW) blockchain, or the
%two-thirds of validators signatures, in the case of a Byzantine
%Fault Tolerant (or BFT) blockchain, it is possible to verify any
%transaction of chain $\mathbb{B}_a$ from chain $\mathbb{B}_b$. With light client
%like verification capabilities of chain $\mathbb{B}_a$ from chain $\mathbb{B}_b$,
%we can imagine the following scenario. Bob has X assets of
%chain $\mathbb{B}_b$. He is willing to exchange them for Y assets of
%chain $\mathbb{B}_a$.  \\
%    Bob sets up a smart contract SC1 and locks his
%assets in it (1). This smart contract SC1 is set to release the
%assets to anyone providing the proof that they made a payment
%of Y assets of chain $\mathbb{B}_a$ to Bob’s address. Alice, who is
%interested in this trade, transfers Y assets to Bob’s address (2).
%She retrieves the transaction hash tx and provide it to SC1 (3).
%SC1 calls the relay and asks for verification of transaction tx
%(4). The relay verifies that the transfer has taken place and if
%so, returns ok to SC1 (5). On receiving the answer from the
%relay, SC1 transfers the X assets of $\mathbb{B}_b$ to Alice’s address.

\subsubsection{Timed crypto}
While HTLCs can be an effective solution when supported, it is not possible to realize when both blockchains do not support timelocks. Furthermore, the transactions incure in higher execution costs due to scripting, and they are have additional on-chain data which may reduce privacy. \\

%\begin{figure}[H]
%\begin{pchstack}[center, boxed]
%\pseudocode{
%    \textbf{$P_0(pk(0)\:, sk(0)$)} \< \< \textbf{$P_1(pk(1)\:, sk(1))$} \\[0.1\baselineskip ][\hline] 
%    \<\< \\[-0.5\baselineskip ]
%    \< \sendmessage*{<->}{top={{\Gamma_{\mathsf{KeyGen}}(\mathbb{G},G,q)}}, bottom={\xlonggets{} (sk_0(01), pk(01)) \\ (sk_1(01), pk(01)) \xlongrightarrow{} }} \< \\
%    \<\< (C, \pi) \gets \Pi_{\mathsf{VTD}}.\mathsf{Commit}(sk_1, T) \\
%    \< \sendmessageleft*{(C, \pi)} \< \\
%    \mathsf{starts}\: \mathsf{Timeout}(T - \Delta)
%    \<\< \mathsf{starts}\: \mathsf{Timeout}(T - \Delta) \\
%    \mathsf{if}\: \Pi_{\mathsf{VTD}}.\mathsf{Verify}(pk, C, \pi) \neq 1 \\
%    \qquad \mathsf{abort}\\
%    tx_\mathsf{frz} \gets \mathsf{InitTx}(pk(0), pk(01), \mathsf{swp(a)}, \mathbb{A}) \\
%    \sigma_{\mathsf{frz}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}(sk(0), tx_\mathsf{frz}) \\
%    \mathsf{PubTx}(\sigma_{\mathsf{frz}}, tx_\mathsf{frz}, \mathbb{A}) \\
%    \mathsf{starts}\: \Pi_{\mathsf{VTD}}.\mathsf{ForceOp}(C) \\
%    \<\< \mathsf{do}\: \mathsf{bal} \gets \mathsf{GetBal}(pk(01), \mathbb{A}) \\
%    \<\< \mathsf{while}\: \mathsf{bal} \neq \mathsf{swp(a)}\\
%    \< \sendmessageleft*{pk(1)} \< \\
%    (pk(10), sk(10)) \gets \Pi_{\mathsf{DS}}.\mathsf{KeyGen}(1^\lambda) \\
%    tx_\mathsf{swp} \gets \mathsf{InitTx}(pk(1), pk(10), \mathsf{swp(b)}, \mathbb{A}) \\
%    \< \sendmessage*{<->}{top={{\Gamma_{\mathsf{Swap}} \qquad \qquad \\ P_0 \xlongrightarrow{} (sk_0(01), tx_\mathsf{swp}) \\ (sk_1(01), sk(1)) \xlonggets{} P_1 }}, bottom={lk := \sigma_{swp}(10) \oplus sk_0(01) \xlongrightarrow{} \\  \xlongleftarrow{} \sigma_{swp}(10) \qquad \qquad  }} \< \\
%    \mathsf{PubTx}(\sigma_{\mathsf{swp(10)}}, tx_\mathsf{frz}, \mathbb{A}) \\
%    \<\< \mathsf{do}\: \sigma_{swp}(10) \gets \mathsf{GetSig}(pk(1), \mathbb{B}) \\
%    \<\< \qquad sk(01) \gets (lk \oplus \sigma_{swp}(10)) + sk_1 \\
%    \<\< \qquad \sigma_{m} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}(sk(01), 1) \\
%    \<\< \mathsf{while}\: \Pi_{\mathsf{DS}}.\mathsf{Verify}(m, pk, \sigma_{m}) \neq 1 \\
%}
%\end{pchstack}
%\caption{Universal atomic swap protocol execution for a successful swap}
%\end{figure}
%

\subsubsection{Universal Atomic Swaps}

One of the first works proposing an atomic swap protocol that substitutes blockchain timelocks with a cryptographic primitive has been proposed by Thyagarajan et al. \cite{uas}, which utilizes Verifiable Timed Signatures (VTS) \cite{vts} as the core building block.

A VTS lets a user generate a timed commitment $C$ of a signature $\sigma$ on a message $m$ under a public key $\mathsf{pk}$. The commitment $C $ must hide the signature $\sigma$ for time $\mathsf{T}$. At the same time, the committer also generates a proof $\pi$ that proves that the commitment $C$ contains a valid signature $\sigma$. This guarantees that $\sigma$ can be publicly recovered in time $\mathsf{T}$ by anyone who solves the computational puzzle.

Let $P_0$ and $P_1$ be two parties where $P_0$ wants to exchange $\mathsf{amnt_a}$ on blockchain $\mathbb{A}$ from their address $\mathsf{pk_{init(\mathbb{A})}}$ for $\mathsf{amnt_b}$ on blockchain $\mathbb{B}$ to $\mathsf{pk_{swp(\mathbb{B})}}$ and vice-versa for $P_1$.

In the setup phase of the protocol, the parties run a 2PC protocol to setup two freeze address on the respective chains $\mathsf{pk_{frz(\mathbb{A})}}$ and $\mathsf{pk_{frz(\mathbb{B})}}$, where each party posseses one share of the respective secret keys, e.g. $\mathsf{sk_{frz(\mathbb{A})}} := \mathsf{sk_{frz0}} \oplus  \mathsf{sk_{frz1}}$. \\
Now the parties create a refund transaction transferring back the assets in case of timeout, for $P_0$ we have $\mathsf{tx_{rfnd(\mathbb{A})}}$ refunding $\mathsf{amnt_a}$ from $\mathsf{pk_{frz(\mathbb{A})}}$ to $\mathsf{pk_{init(\mathbb{A})}}$ and similarly for $P_1$ $\mathsf{tx_{rfnd(\mathbb{B})}}$. Now each party generates a timed commitment on the signature of the counterparty's refund transaction, where $P_0$ receives a $\mathsf{VTS}$ with commitment $C_0$ and timeout $T_0 = T_1 + \Delta$ and $P_1$ receives a $\mathsf{VTS}$ with commitment $C_1$ and timeout $T_1$. Once both $\mathsf{VTS}$ commitment are verified the parties can proceed to transfer the assets to the freeze addresses, as they are guaranteed to  retreive the signature of the refund transaction after they force open the commitments after the specified timeouts. \\

In the subsequential lock phase, parties first initialize the swap transactions $\mathsf{tx_{swp}}$ transferring $\mathsf{amnt}$ from $\mathsf{pk_{frz}}$ to $\mathsf{pk_{swp}}$ for the respective chains and then compute via 2PC $\mathsf{lk} := \sigma_{swp(\mathbb{A})} \oplus \mathcal{H}(\sigma_{swp(\mathbb{B})})$, where the output for $P_0$ is $\sigma_{swp(\mathbb{B})}$ and $\mathsf{lk}$ for $P_1$. Now when $P_0$ publishes $\mathsf{tx_{swp(\mathbb{B})}}$ together with  $\sigma_{swp(\mathbb{B})}$, $P_1$ will be able to unmask $\mathsf{lk}$ by computing $\mathcal{H}(\sigma_{swp(\mathbb{B})})$ and thus retrieving $\sigma_{swp(\mathbb{A})}$ and publishing $\mathsf{tx_{swp(\mathbb{A})}}$.

In case $P_0$ fails to publish $\mathsf{tx_{swp(\mathbb{B})}}$ before $T_1$, $P_1$ will publish refund transaction  $\mathsf{tx_{rfnd(\mathbb{B})}}$ and similarly for $P_0$ if $P_1$ timeouts during the protocol execution. \\

We note however that the protocol fails to take into account two possible racing conditions: \\
1) the party $P_0$ can wait until $T_1$ to post $\mathsf{tx_{swp(\mathbb{B})}}$ , when $P_1$ is posting the refund transaction $\mathsf{tx_{rfnd(\mathbb{B})}}$. Since $\mathsf{tx_{rfnd(\mathbb{B})}}$ is not confirmed until $\mathbb{B}.\mathsf{ctime}$, there is an equal probability that $\mathsf{tx_{swp(\mathbb{B})}}$ will win the race, thus $P_1$ will be unable to refund the assets. \\ 
2) Similarly, if $P_0$ posts $\mathsf{tx_{swp(\mathbb{B})}}$ after $T_1 - \mathbb{B}.\mathsf{ctime}$, $P_1$ can now try to simultaneously post $\mathsf{tx_{rfnd(\mathbb{B})}}$ and $\mathsf{tx_{swp(\mathbb{A})}}$ \\

Thus in order to preserve the atomicity property, we propose the following changes: \\
1) When $P_1$ timeouts on $T_1$ the party should check, while $\mathsf{tx_{rfnd(\mathbb{B})}}$ is unconfirmed, if $P_0$ is publishing $\mathsf{tx_{swp(\mathbb{B})}}$ and if so retrieve $\sigma_{swp(\mathbb{A})}$ and publish $\mathsf{tx_{swp(\mathbb{A})}}$. It is also required that $\Delta > \mathbb{A}.\mathsf{ctime} + \mathsf{B}.\mathsf{ctime}$ \\
2) $P_0$ should be required to post $\mathsf{tx_{swp(\mathbb{B})}}$ no later than $T_1 - \mathbb{B}.\mathsf{ctime}$, and abort otherwise \\

Note that parties must also take into account potential differences in the computational power available for force opening the VTS commitments. This is to prevent scenarios where Alice or Bob with a powerful machine force opens its VTS commitments earlier than expected in terms of real time, resulting in being able 
to steal the coins of the other party during the swap lock or swap complete phase. In particular, the parties must ensure that $\Delta$ (such that T0 = T1 + $\Delta$) is large enough such that it tolerates the time differences to open the VTS commitments. \\

Parties are incentivized to make worst-case estimates for the counterparty's computational power which can be orders of magnitude faster when accounting for novel algorithms \cite{squaring_algo} and application-specific integrated circuits (ASIC) \cite{squaring_asic}. \\
This leads to an impractical protocol, as parties may need to uninterruptedly compute a force opening for a significant amount of time.







\subsection{Contribution}

We propose an alternative construction of a timed-crypto based atomic swap protocol which uses a one-sided refund timed commitment.  \\
The protocol is asymmetric, with one party acting as a client, who is required to compute a short timed commitment equivalent to the blockchains confimation time, and the other party functioning as an exchange server, force opening the timed commitment with timelock $T_0$.
This approach also eliminates the need to set up a freeze wallet for the client, reducing the number of transactions for a successful swap.

We furthermore define a new interface that generalizes timed commitments independent of the underlying construction.

\section{Preliminaries}

\todo[inline]{
Put the basic definitions here, e.g. signatures, hash functions, commitment, blockchains (maybe for this report just do it informally), etc.}

\subsection{Syntax definition}

\begin{itemize}[nosep, noitemsep]
    \item $\mathbf{wait} \: \mathsf{fn}()$ - waits until the function $\mathsf{fn}()$ execution is complete. If $\mathsf{fn}()$ returns $\perp$, then it causes to abort the execution block returning $\perp$. \\
    \item $\mathbf{wait} \: \{...\}$ - enforces $\mathbf{wait}$ to all routines calls inside the block. If the block $\{...\}$ returns $\perp$, then it causes to abort the execution block returning $\perp$. Returns the value of the last evaluated routine. \\
    \item $\mathbf{select} \: \{...\}$ - concurrently runs all the $\mathbf{wait}$ routines in the block and returns the value of the first routine that successfully returns a value or $\perp$ if all the $\mathbf{wait}$ routines aborted with $\perp$. When a $\mathbf{wait}$ routine aborts returning $\perp$, it waits until execution of another $\mathbf{wait}$ is successfully completed. \\
\end{itemize}

In the protocol definition, variables and functions that are blockchain-specific (unless clear from context) are denoted with a subscript, example for a publick key on chain $\mathbb{B}$ we denote $\mathsf{pk_{(\mathbb{B})}}$. \\


\subsection{Blockchain interface}

We define the following oracles to interact with the blockchains. The subscript $\mathbb{A}$ indicates that we are interacting with chain $\mathbb{A}$.

\begin{itemize}[topsep=0pt, itemsep=0pt, leftmargin=2em]
    \item $\mathbf{0/1} \gets \mathbf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{tx}}, \mathsf{tx})$: publish the transaction $\mathsf{tx}$ with signature $\sigma_{\mathsf{tx}}$. Outputs 1 if the transaction is accepted, 0 otherwise.
    \item $\mathbf{tx}_{\mathbb{A}} := (\mathsf{pk_{tx}}, \mathsf{pk_{rx}}, \mathsf{amnt}, \mathsf{id})  \gets \mathbf{InitTx}_{(\mathbb{A})}(\mathsf{pk_{tx}}, \mathsf{pk_{rx}}, \mathsf{amnt})$: creates an unsigned transaction with the unique identifier $\mathsf{id}$ paying $\mathsf{amnt}$ from $\mathsf{pk_{tx}}$ to $\mathsf{pk_{rx}}$.
    \item $\mathbf{0/1} \gets \mathbf{VerifyTx}_{(\mathbb{A})}(\sigma_{\mathsf{tx}}, \mathsf{tx})$: verifies the signature of the transaction and the validity of the transaction based on consensus rules. Outputs 1 if the verification succeeds, 0 otherwise.
    \item $\mathbf{0/1} \gets \mathbf{WatchTx}_{(\mathbb{A})}(\mathsf{tx})$: wait for the transaction $\mathsf{tx}$ to be confirmed.
    \item $\mathbf{amnt} \gets \mathbf{GetBal}_{(\mathbb{A})}(\mathsf{pk})$: get the balance of assets held by $\mathsf{pk}$
    \item $(\sigma_{\mathsf{tx}}, \mathsf{tx}) \gets \mathbf{GetLatestTx}_{(\mathbb{A})}(\mathsf{pk})$: get the the latest confirmed transaction and its signature from $\mathsf{pk}$'s record on the chain
    \item $\mathbf{ctx}_{\mathbb{A}} := (\mathsf{tx_{\mathbb{A}}}, C) \gets \mathbf{CommitTx}_{(\mathbb{A})}(C, \mathsf{pk_{tx}}, \mathsf{pk_{rx}}, \mathsf{amnt}, \mathsf{t})$: creates an unsigned commit transaction paying $\mathsf{amnt}$ from $\mathsf{pk_{tx}}$ to $\mathsf{pk_{rx}}$ valid until block $\mathsf{t}$. The transaction can be later completed by opening and broadcasting $C$ through $\mathsf{RevTx}$
    \item $ \mathbf{0/1} \gets \mathbf{RevTx}_{(\mathbb{A})}(\mathsf{sec}, \mathsf{tx})$: open the (on-chain) committed transaction $\mathsf{tx}$ by revealing the commited secret $\mathsf{sec}$
\end{itemize}

\subsection{Security definitions}

\textbf{Definition 1} (Atomicity): \textit{Either both parties successfully exchange each other's assets or neither party performs a successful swap.}
\vspace{0.5em}
\\
That is, after the protocol run there can be only two outcomes: \\
1) $P_0$ holds $\mathsf{amnt_b}$ on $\mathsf{pk_{swp(\mathbb{B})}}$ and $P_1$ holds $\mathsf{amnt_a}$ on $\mathsf{pk_{swp(\mathbb{A})}}$ (successful swap) \\
2) $P_0$ holds $\mathsf{amnt_a}$ on $\mathsf{pk_{init(\mathbb{A})}}$ and $P_1$ holds $\mathsf{amnt_b}$ on $\mathsf{pk_{init(\mathbb{B})}}$ or $\mathsf{pk_{rfnd(\mathbb{B})}}$ (swap aborted) \\

\textbf{Definition 2} (Ownership): \textit{All parties gain exclusive knowledge of the secret keys of their respective wallets holding the exchanged or refunded assets upon completion of the protocol.} 
\vspace{0.5em}
\\
That is after a successful protocol run $P_0$ owns $\mathsf{sk_{swp(\mathbb{B})}}$ and $P_1$ owns $\mathsf{sk_{swp(\mathbb{A})}}$, and respectively for the aborted swap  $\mathsf{sk_{init(\mathbb{A})}}$ and $\mathsf{sk_{init(\mathbb{B})}}$ or $\mathsf{sk_{rfnd(\mathbb{B})}}$. \\


\section{Atomic Swaps from Commit Transactions}

%\todo[inline]{For the current report, put a formal syntax, but maybe informal definitions of correctness and security. Especially, there should be an (informal) definition of commit transaction. }




%\todo[inline]{Set things up (e.g. let ... be a signature scheme, ... be a ... scheme. We construct a ... in Figure ...)}


\subsection{Version 0}

Parties $P_0$ and $P_1$ hold assets $a$ on blockchain $\mathbb{A}$ and assets $b$ on chain $\mathbb{B}$ respectively. \\
We define with $\mathsf{amnt_a}$ and $\mathsf{amnt_b}$ the amount of the assets the parties agreed to swap before starting the protocol.
%\textbf{Definition 1} (encrypted Verifiable Timed Discrelog) \\
%Public parameters $(\mathbb{G}, G, T)$ \\
%- $(eC, C, d, \pi) \gets \mathsf{Commit}(x, y, \textbf{T}$): the commit algorithm (randomized) takes as input a discrete log value $x \in \mathbb{Z}_q$, a hiding time $\textbf{T}$ and an encryption key $ y \in \mathbb{Z}_q$ and outputs a commitment $eC$ containing the encrypted puzzles, a commitment $C$ of $y$ with opening $d$ and a proof $\pi$. \\
%- $(0,1) \gets \mathsf{Verify}(H, eC, C, \pi)$: returns 1 if and only if the value $x$ embedded in $C$ decrypts $eC$ such that the value $y$ in decrypted $eC$ satisfies $H = G^y$  \\ \\
%- $(y, d) \gets \mathsf{ForceOp}(eC, x)$: the force open algorithm takes as input the encrypted commitment $eC$ and the encryption key $x$, outputs the committed value $y$ and the randomness $d$ used in generating $eC$

\[
    \mathcal{L}_{\mathsf{lock}} := \left\{\begin{array}{lr}  \mathsf{stmt} = (lk, y, h, \pi, T) : \exists (x) \:\: \text{s.t} \\
    (\mathcal{H}(x) = h \land \Pi_\mathsf{VTD}.\mathsf{Verify}(y, (lk \oplus x), \pi, T)) \end{array}\right\}
\]

\begin{figure}[H]
\begin{pchstack}[center, boxed]
\pseudocode{
	P_0(\mathsf{sk_{frz0(\mathbb{B})}}) \< \< P_1(\mathsf{sk_{frz1(\mathbb{B})}}, \mathsf{tx_{rfnd}}) \\[0.1\baselineskip ][\hline] 
    \<\< \\[-0.5\baselineskip ]
    \mathsf{sk_{frz}} := \mathsf{sk_{frz0}} + \mathsf{sk_{frz1}} \\
    \sigma_\mathsf{rfnd(\mathbb{B})} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign_{(\mathbb{B})}}(\mathsf{sk_{frz}}, \mathsf{tx_{rfnd}})
}
\end{pchstack}
\caption{Protocol definition of 2PC $\Gamma_{\mathsf{Refund}}$}
\end{figure}

\begin{figure}[H]
\begin{pchstack}[center, boxed]
\pseudocode{
    P_0(\mathsf{sk_{frz0(\mathbb{B})}}, \mathsf{tx_{swp}}) \< \< P_1(\mathsf{sk_{frz1(\mathbb{B})}}, \mathsf{hpk}) \\[0.1\baselineskip ][\hline] 
    \<\< \\[-0.5\baselineskip ]
    \mathsf{\textbf{if}} \:\: \mathcal{H}(\mathsf{tx_{swp}}.\mathsf{pk_{rx}}) \neq \mathsf{hpk} \lor \mathsf{tx_{swp}}.\mathsf{amnt} \neq \mathsf{amnt_b} \\
    \qquad \mathsf{\textbf{return}} \perp \\
    \mathsf{sk_{frz}} := \mathsf{sk_{frz0}} + \mathsf{sk_{frz1}} \\
    \sigma_\mathsf{swp(\mathbb{B})} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign_{(\mathbb{B})}}(\mathsf{sk_{frz}}, \mathsf{tx_{swp}})
}
\end{pchstack}
\caption{Protocol definition of 2PC $\Gamma_{\mathsf{Swap}}$}
\end{figure}




\begin{figure}[H]
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (\mathbb{G}, [1], q, T_0, T_1, T_2, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    (\mathsf{sk_{frz0}}, \mathsf{pk_{frz}})_{(\mathbb{A})} \gets \mathsf{\textbf{wait}} \:\: \Gamma_{\mathsf{KeyGen}_{(\mathbb{A})}} \\
    (\mathsf{sk_{frz1}}, \mathsf{pk_{frz}})_{(\mathbb{B})} \gets \mathsf{\textbf{wait}} \:\: \Gamma_{\mathsf{KeyGen}_{(\mathbb{B})}} \\
    \Gamma_{\mathsf{Refund}}(\mathsf{sk_{frz1(\mathbb{B})}}, \mathsf{tx_{rfnd(\mathbb{B})}}) \\
    (C_0, \pi_0, \pi_1, \pi_2, \mathsf{hsig}, \mathsf{lk_0} ) \gets \mathsf{\textbf{wait}} \:\: \mathsf{receive}(P_1) \\
    \mathsf{\textbf{if}} \:\: \Pi_{\mathsf{VTD}}.\mathsf{Verify}(\mathsf{pk_{frz(\mathbb{A})}} - [\mathsf{sk_{frz0(\mathbb{A})}}], C_0, \pi) \neq 1 \\
    \quad \mathsf{\textbf{return}} \perp \\
    \mathsf{\textbf{if}} \:\: \Pi_{\mathsf{ZK}\mathcal{L}_{\mathsf{lock}}}.\mathsf{Vr}((\mathsf{lk_0}, \mathsf{pk_{frz(\mathbb{A})}} - [\mathsf{sk_{frz1(\mathbb{A})}}], \mathsf{hsig}, \pi_1, T_1), \pi_2) \neq 1 \\
    \quad \mathsf{\textbf{return}} \perp \\
    \mathsf{\textbf{select}} \:\: \{ \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{sk_{frz1}} \gets \Pi_{\mathsf{VTD}}.\mathsf{ForceOp}(C_0) \\
    \qquad \mathsf{sk_{frz(\mathbb{A})}} := \mathsf{sk_{frz0}} + \mathsf{sk_{frz1}} \\
    \qquad \mathsf{tx_{rfnd(\mathbb{A})}} \gets \mathsf{InitTx}_{(\mathbb{A})}(\mathsf{pk_{frz}}, \mathsf{pk_{init}}, \mathsf{amnt_a}) \\
    \qquad \sigma_{\mathsf{rfnd(\mathbb{A})}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}_{(\mathbb{A})}(\mathsf{sk_{frz}}, \mathsf{tx_{rfnd}}) \\
    \qquad \mathsf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{rfnd}}, \mathsf{tx_{rfnd}}) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{\textbf{do}} \:\: (\sigma_{\mathsf{tx_{rfnd}}}, \_) \gets \mathsf{GetLatestTx}_{(\mathbb{B})}(\mathsf{pk_{frz}}) \\
    \qquad \mathsf{\textbf{while}} \:\: \mathcal{H}(\sigma_{\mathsf{tx_{rfnd}}}) \neq {\mathsf{hsig}} \\
    \qquad C_1 := \mathsf{lk_0} \oplus \sigma_{\mathsf{tx_{rfnd}}} \\
    \qquad \mathsf{sk_{frz1(\mathbb{A})}} \gets \Pi_\mathsf{VTD}.\mathsf{ForceOp}(C_1) \\
    \qquad \mathsf{sk_{frz(\mathbb{A})}} := \mathsf{sk_{frz0}} + \mathsf{sk_{frz1}} \\
    \qquad \mathsf{tx_{rfnd(\mathbb{A})}} \gets \mathsf{InitTx}_{(\mathbb{A})}(\mathsf{pk_{frz}}, \mathsf{pk_{init}}, \mathsf{amnt_a}) \\
    \qquad \sigma_{\mathsf{rfnd(\mathbb{A})}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}_{(\mathbb{A})}(\mathsf{sk_{frz}}, \mathsf{tx_{rfnd}}) \\
    \qquad \mathsf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{rfnd}}, \mathsf{tx_{rfnd}}) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad  (\mathsf{pk_{swp}}, \mathsf{sk_{swp}})_{(\mathbb{B})} \gets \Pi_{\mathsf{DS}}.\mathsf{KeyGen_{(\mathbb{B})}}(1^\lambda) \\
    \qquad \mathsf{tx_{frz(\mathbb{A})}} \gets \:\: \mathsf{InitTx}_{(\mathbb{A})}(\mathsf{pk_{init}}, \mathsf{pk_{frz}}, \mathsf{amnt_a}) \\
    \qquad \sigma_{\mathsf{frz(\mathbb{A})}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}_{(\mathbb{A})}(\mathsf{sk_{init}}, \mathsf{tx_{frz}}) \\
    \qquad \mathsf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{frz}}, \mathsf{tx_{frz}}) \\
    \qquad \mathsf{pk_{init(\mathbb{B})}} \gets  \mathsf{receive}(P_1) \\
    \qquad \mathsf{tx_{swp(\mathbb{B})}} \gets \mathsf{InitTx}_{(\mathbb{B})}(\mathsf{pk_{frz}}, \mathsf{pk_{swp}}, \mathsf{amnt_b}) \\
    \qquad (C_2, \pi_3) \gets \Pi_\mathsf{VTD}.\mathsf{Commit}(\mathsf{sk_{frz0}}, T_2) \\
    \qquad \mathsf{lk_1} := \mathsf{pk_{swp(\mathbb{B})}} \oplus C_2 \\
    \qquad \mathsf{hpk} \gets \mathcal{H}(\mathsf{pk_{swp(\mathbb{B})}}) \\
    \qquad \pi_4 \gets \Pi_{\mathsf{ZK}\mathcal{L}_{\mathsf{lock}}}.\mathsf{Pr}((\mathsf{lk_1}, [\mathsf{sk_{frz0}}], \mathsf{hpk}, \pi_3, T_2), \mathsf{pk_{swp(\mathbb{B})}}) \\
    \qquad \mathsf{send}(P_1, \pi_3, \pi_4, \mathsf{hpk}, \mathsf{lk_1}) \\
    \qquad \sigma_{\mathsf{swp(\mathbb{B})}} \gets \Gamma_{\mathsf{Swap}}(\mathsf{sk_{frz0(\mathbb{B})}}, \mathsf{tx_{swp(\mathbb{B})}}) \\
    \qquad \textbf{if} \:\: \mathsf{VerifyTx}_{(\mathbb{B})}(\sigma_{\mathsf{swp}}, \mathsf{tx_{swp}}) \neq 1 \\
    \qquad \quad \mathsf{\textbf{return}} \perp \\
    \qquad \mathsf{PubTx}_{(\mathbb{B})}(\sigma_{\mathsf{swp}}, \mathsf{tx_{swp}}) \\
    \qquad \mathsf{send}(P_1) \\
    \quad \} \\
    \} \\
}
\end{pchstack}
\end{minipage}%
\hspace{0.01\textwidth} 
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (\mathbb{G}, [1], q, T_0, T_1, T_2, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    (\mathsf{sk_{frz1}}, \mathsf{pk_{frz}})_{(\mathbb{A})} \gets \mathsf{\textbf{wait}} \:\: \Gamma_{\mathsf{KeyGen}_{(\mathbb{A})}} \\
    (\mathsf{sk_{frz1}}, \mathsf{pk_{frz}})_{(\mathbb{B})} \gets \mathsf{\textbf{wait}} \:\: \Gamma_{\mathsf{KeyGen}_{(\mathbb{B})}} \\
    \mathsf{tx_{rfnd(\mathbb{B})}} \gets \mathsf{InitTx}_{(\mathbb{B})}(\mathsf{pk_{frz}}, \mathsf{pk_{init}}, \mathsf{amnt_b}) \\
    \sigma_{\mathsf{rfnd(\mathbb{B})}} \gets \Gamma_{\mathsf{Refund}}(\mathsf{sk_{frz1(\mathbb{B})}}, \mathsf{tx_{rfnd(\mathbb{B})}}) \\
    \mathsf{\textbf{if}} \:\: \mathsf{VerifyTx}_{(\mathbb{B})}(\sigma_{\mathsf{rfnd}}, \mathsf{tx_{rfnd}}) \neq 1 \\
    \quad \mathsf{\textbf{return}} \perp \\
    (C_0, \pi_0) \gets \Pi_{\mathsf{VTD}}.\mathsf{Commit}(\mathsf{sk_{frz1(\mathbb{A})}}, T_0) \\
    (C_1, \pi_1) \gets \Pi_\mathsf{VTD}.\mathsf{Commit}(\mathsf{sk_{frz1(\mathbb{A})}}, T_1) \\
    \mathsf{lk_0} := \sigma_{\mathsf{rfnd(\mathbb{B})}} \oplus C_1 \\
    \mathsf{hsig} \gets \mathcal{H}(\sigma_{\mathsf{rfnd(\mathbb{B})}}) \\
    \pi_2 \gets \Pi_{\mathsf{ZK}\mathcal{L}_{\mathsf{lock}}}.\mathsf{Pr}((\mathsf{lk_0}, [\mathsf{sk_{frz1}}], \mathsf{hsig}, \pi_1, T_1), \sigma_{\mathsf{rfnd(\mathbb{B})}}) \\
    \mathsf{\textbf{wait}} \:\: \mathsf{send}(P_0,\: (C_0, \pi_0, \pi_1, \pi_2, \mathsf{hsig}, \mathsf{lk_0})) \\
    \mathsf{\textbf{select}} \:\: \{ \\
        \quad \mathsf{\textbf{wait}} \:\: \{ \\
            \qquad \mathsf{timeout}(T_0/2) \\
            \qquad \mathsf{PubTx}_{(\mathbb{B})}(\sigma_{\mathsf{rfnd}}, \mathsf{tx_{rfnd}}) \\
        \quad \} \\
        \quad \mathsf{\textbf{wait}} \:\: \{ \\
            \qquad \mathsf{\textbf{do}} \:\: \mathsf{bal} \gets \mathsf{GetBal}_{(\mathbb{A})}(\mathsf{pk_{frz}}) \\
            \qquad \mathsf{\textbf{while}} \:\: \mathsf{bal} \neq {\mathsf{amnt_a}} \\
            \qquad \mathsf{send}(P_0,\: \mathsf{pk_{init}}) \\
	    \qquad (\pi_3, \pi_4, \mathsf{hpk}, \mathsf{lk_1}) \gets \mathsf{receive}(P_0) \\
	    \qquad \mathsf{\textbf{if}} \:\: \Pi_{\mathsf{ZK}\mathcal{L}_{\mathsf{lock}}}.\mathsf{Vr}((\mathsf{lk_1}, \mathsf{pk_{frz(\mathbb{A})}} - [\mathsf{sk_{frz1(\mathbb{A})}}], \mathsf{hpk}, \pi_3, T_2), \pi_4) \neq 1 \\
                \qquad \quad \mathsf{\textbf{return}} \perp \\
            \qquad \Gamma_{\mathsf{Swap}}(\mathsf{sk_{frz1(\mathbb{B})}}, \mathsf{hpk}) \\
            \qquad \mathsf{receive}(P_0) \\
            \qquad (\_, \mathsf{tx_{swp(\mathbb{B})}}) \gets \mathsf{GetLatestTx}_{(\mathbb{A})}(\mathsf{pk}) \\
	    \qquad C_2 := \mathsf{lk_1} \oplus \mathsf{tx_{swp(\mathbb{B})}}.\mathsf{pk_{rx}} \\
            \qquad \mathsf{sk_{frz0}} \gets \Pi_\mathsf{VTD}.\mathsf{ForceOp}(C_2) \\
            \qquad \mathsf{tx_{swp(\mathbb{A})}} \gets \mathsf{InitTx}_{(\mathbb{A})}(\mathsf{pk_{frz}}, \mathsf{pk_{swp}}, \mathsf{amnt_a}) \\
            \qquad \sigma_{\mathsf{swp(\mathbb{A})}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}_{(\mathbb{A})}(\mathsf{sk_{frz0}} + \mathsf{sk_{frz1}}, \mathsf{tx_{rfnd}}) \\
            \qquad \mathsf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{swp}}, \mathsf{tx_{swp}}) \\
        \quad \} \\
    \} \\
}
\end{pchstack}
\end{minipage}%
\caption{Full protocol execution for $P_0$ and $P_1$, respectively left and right (alternative syntax)}
\end{figure}



\subsection{Version 1} Protocol version using commitment transaction with arbitrary value replacing VTD. \\
\begin{figure}[H]
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (\mathbb{G}, [1], q, T, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    \mathsf{sec} \gets \mathbb{Z}_q \\
    (C_0, r) \gets \Pi_{\mathsf{PCom}}.\mathsf{Commit}(\mathsf{sec_0}) \\ % verify that sec_0 has been commited
    \mathsf{ctx_{(\mathbb{A})}} \gets \mathsf{CommitTx}_{(\mathbb{A})}(C_0, \mathsf{pk_{init}}, \mathsf{pk_{swp}}, \mathsf{amnt_a}, T + \Delta) \\
    \sigma_{\mathsf{ctx_{(\mathbb{A})}}} \gets \Pi_{\mathsf{DS}}.\mathsf{Sign}_{(\mathbb{A})}(\mathsf{sk_{init}}, \mathsf{ctx}) \\
    \mathsf{PubTx}_{(\mathbb{A})}(\sigma_{\mathsf{ctx}}, \mathsf{ctx}) \\
    \mathsf{\textbf{select}} \:\: \{ \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{timeout}(T) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{send}(\mathsf{ctx_{(\mathbb{A})}}) \\
    \qquad \mathsf{receive}(\mathsf{ctx_{(\mathbb{B})}}) \\
    \qquad \mathsf{res_1} \gets \mathsf{\textbf{wait}} \:\: \mathsf{WatchTx}_{(\mathbb{B})}(\mathsf{ctx}) \\
    \qquad \mathsf{\textbf{if}} \:\: \mathsf{ctx}_{(\mathbb{B})}.C \neq C_0 \lor \mathsf{ctx}_{(\mathbb{B})}.T \neq T \lor \mathsf{res_1} \neq 1 \\ % verify that commit transaction is valid and accepted
    \qquad \quad \mathsf{\textbf{return}} \perp \\
    \qquad \mathsf{rtx_{swp(\mathbb{B})}} \gets \mathsf{RevTx}_{(\mathbb{B})}(\mathsf{sec}, \mathsf{ctx}) \\
    \quad \} \\
    \} \\
}
\end{pchstack}
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
\begin{pchstack}[boxed]
\pseudocode{
    \text{Global input} \:\: (\mathbb{G}, [1], q, T, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
    \mathsf{receive}(\mathsf{ctx_{(\mathbb{A})}}) \\
    \mathsf{res_0} \gets \mathsf{\textbf{wait}} \:\: \mathsf{WatchTx}_{(\mathbb{A})}(\mathsf{ctx}) \\
    \mathsf{\textbf{select}} \:\: \{ \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{timeout}(T) \\
    \quad \} \\
    \quad \mathsf{\textbf{wait}} \:\: \{ \\
    \qquad \mathsf{\textbf{if}} \:\: \mathsf{ctx_{(\mathbb{A})}}.T \neq T + \Delta \lor \mathsf{res_0} \neq 1 \\ % verify that commit transaction is valid and accepted
    \qquad \quad \mathsf{\textbf{return}} \perp \\
    \qquad \mathsf{ctx}_{(\mathbb{B})} \gets \mathsf{CommitTx}_{(\mathbb{B})}(C_0, \mathsf{pk_{init}}, \mathsf{pk_{swp}}, \mathsf{amnt_b}, T) \\
    \qquad \mathsf{send}(\mathsf{ctx}_{(\mathbb{B})}) \\
    \qquad \mathsf{rtx_{swp(\mathbb{B})}} \gets \mathsf{\textbf{wait}} \:\: \mathsf{GetLatestTx}_{(\mathbb{B})}(\mathsf{pk_{swp}}) \\
    \qquad \mathsf{sec} := \mathsf{rtx_{swp(\mathbb{B})}}.\mathsf{rev} \\
    \qquad \mathsf{rtx_{swp(\mathbb{A})}} \gets \mathsf{RevTx}_{(\mathbb{A})}(\mathsf{sec}, \mathsf{ctx}) \\
    \quad \} \\
    \} \\
}
\end{pchstack}
\end{minipage}%
\caption{Full protocol execution for $P_0$ and $P_1$, respectively left and right}
\end{figure}


\section{Proof sketch}

\todo[inline]{Informal theorems for correctness and security and proof sketch}

We model the interaction in a zero trust setting: both parties are mutually distrusting and potentially malicious as they have an incentive to deceive the counter-party. \\
We further assume that a party cannot deny the counter-party from transacting on the blockchain or performing local computations.


\subsection{Party $P_0$}
We want to prove that $P_0$ at the end of a protocol run either holds $\mathsf{amnt_a}$ on $\mathsf{pk_{init(\mathbb{A})}}$ with exclusive knowledge of $\mathsf{sk_{init(\mathbb{A})}}$ or they hold $\mathsf{amnt_b}$ on $\mathsf{pk_{swp(\mathbb{B})}}$ with exclusive knowledge of $\mathsf{sk_{swp(\mathbb{B})}}$. \\


$P_0$ signs and publishes a transaction transferring $\mathsf{amnt_a}$ from $\mathsf{pk_{init(\mathbb{A})}}$ to the freeze wallet $\mathsf{pk_{frz(\mathbb{A})}}$ if and only if $\Pi_{\mathsf{VTD}}.\mathsf{Verify}(\mathsf{pk_{frz}} - [\mathsf{sk_{frz0}}], C_0, \pi_0) = 1$, thus by the soundess property of the VTD scheme $P_0$ is guaranteed of retrieving the commited diiscrete log value $x$ in $C_0$ that satisfies $[x] =  \mathsf{pk_{frz}} - [\mathsf{sk_{frz0}}]$ after $T$ steps. \\
Note that $\mathsf{pk_{frz}}$ has been generated in the 2PC protocol $\Gamma_{\mathsf{KeyGen}}$ with $\mathsf{pk_{frz}} := [\mathsf{sk_{frz0}} + \mathsf{sk_{frz1}}]$, hence we have $[x] = [\mathsf{sk_{frz0}} + \mathsf{sk_{frz1}}] - [\mathsf{sk_{frz0}}] = [\mathsf{sk_{frz1}}]$. \\

The party proceeds to concurrently runs two execution paths denoted by $\textbf{wait}$, with one being the refund branch and the other performing the swap. We note that from this point onwards, if any routine in the swapping branch timeouts or faults, $P_0$ will keep executing the refund branch. \\
$P_0$ generates a new keypair $(\mathsf{pk_{swp}}, \mathsf{sk_{swp}})$ on $\mathbb{B}$, retrieves $\mathsf{pk_{init(\mathbb{B})}}$ from $P_1$ and  initialize the transaction $\mathsf{tx_{swp(\mathbb{B})}}$ transferring $\mathsf{amnt_b}$ from $\mathsf{pk_{init(\mathbb{B})}}$ to $\mathsf{pk_{swp(\mathbb{B})}}$.
They now proceed to commit their own secret share of $\mathsf{sk_{frz}}$ to $C_1$ with $\Pi_\mathsf{VTD}.\mathsf{Commit}(\mathsf{sk_{frz0}}, T_1)$ and generate a lock for the commitment $lk := C_1 \oplus \mathsf{pk_{swp(\mathbb{B})}}$, where $\mathsf{pk_{swp(\mathbb{B})}}$ is secret to $P_1$. \\
% They send the lock together with a proof of 
Note that $P_1$ gains no information about $\mathsf{pk_{swp(\mathbb{B})}}$ and thus can retrieve $C_1$ from $lk$ and force opening it only after $\mathsf{tx_{swp}}$ has been published by $P_0$. The privacy provery of the VTD scheme ensures that $P_1$ will retrieve $\mathsf{sk_{frz0}}$ only after time $T_1$, and since $T_1 \geq \mathbb{B}.\mathsf{ctime}$ $P_1$ will gain knowledge of $\mathsf{sk_{frz}}$ only after $P_0$ holds $\mathsf{amnt_b}$ on $\mathsf{pk_{swp(\mathbb{B})}}$.

Now assume instead that some routine in the swapping execution branch timed out or faulted, resulting in $\Pi_{\mathsf{VTD}}.\mathsf{ForceOp}(C_0)$ being solved: the party retrieves $\mathsf{sk_{frz}}$ to sign and publish $\mathsf{tx_{rfnd(\mathbb{A})}}$ transferring back $\mathsf{amnt_a}$ from $\mathsf{pk_{frz(\mathbb{A})}}$ to $\mathsf{pk_{init(\mathbb{A})}}$, thus resulting in $P_0$ holding $\mathsf{amnt_a}$ on $\mathsf{pk_{init(\mathbb{A})}}$.


\subsection{Party $P_1$}
We want to prove that $P_1$ at the end of a protocol run either holds $\mathsf{amnt_b}$ on $\mathsf{pk_{init(\mathbb{B})}}$ with exclusive knowledge of $\mathsf{sk_{init(\mathbb{B})}}$ or they hold $\mathsf{amnt_a}$ on $\mathsf{pk_{swp(\mathbb{A})}}$ with exclusive knowledge of $\mathsf{sk_{swp(\mathbb{A})}}$. \\

After jointly generating $\mathsf{pk_{frz(\mathbb{A})}}$ with the 2PC protocol $\Gamma_{\mathsf{KeyGen}}$, $P_1$ commits $\mathsf{sk_{frz1}}$ with $\Pi_{\mathsf{VTD}}.\mathsf{Commit}(\mathsf{sk_{frz1}}, T_0)$. 
The party proceeds to concurrently runs two execution paths denoted by $\textbf{wait}$, with one being the refund branch and the other performing the swap. We note that from this point onwards, if any routine in the swapping branch timeouts or faults, $P_1$ will keep executing the refund branch. \\

The refund branch has a timeout 
It then proceeds to wait until $\mathsf{amnt_a}$ has been transferred to $\mathsf{pk_{frz(\mathbb{A})}}$ and retrieves a tuple $(\pi_1, \pi_2, \mathsf{hpk}, lk)$ from $P_0$ and proceeds to run $\Pi_{\mathsf{ZK}\mathcal{L}_{\mathsf{lock}}}.\mathsf{Vr}((lk, \mathsf{pk_{frz}} - [\mathsf{sk_{frz1}}], \mathsf{hpk}, \pi_1, T_1), \pi_2)$, verifying that $\exists(pk) \:\: \text{s.t} \:\: \mathcal{H}(pk) = h \land \Pi_\mathsf{VTD}.\mathsf{Verify}(\mathsf{pk_{frz}} - [\mathsf{sk_{frz1}}], (lk \oplus pk), \pi, T_1)$. Thus $P_1$ now knows the hash value $hpk$ of a public key$pk$ that can unlock a timed commitment from $lk$ which holds a discrete log value $x$ that satisfies  $[x] = \mathsf{pk_{frz}} - [\mathsf{sk_{frz1}}] = [\mathsf{sk_{frz0}} + \mathsf{sk_{frz1}}] - [\mathsf{sk_{frz1}}] = [\mathsf{sk_{frz0}}]$, hence $x = \mathsf{sk_{frz0}}$.

The parties then run the 2PC protocol $\Gamma_{\mathsf{Swap}}$ where $P_1$ signs $\mathsf{tx_{swp(\mathbb{B})}}$ (which is unknown by the 2PC input privacy property) unless $\mathcal{H}(\mathsf{tx_{swp}}.\mathsf{pk_{rx}}) \neq \mathsf{hpk} \lor  \mathsf{tx_{swp}}.\mathsf{amnt} \neq \mathsf{amnt_b}$, in which case it aborts from the protocol. \\

Since $\mathcal{H}(\mathsf{tx_{swp(\mathbb{B})}}.\mathsf{pk_{rx}}) = \mathsf{hpk}$,  $\mathsf{pk_{rx}}$ is a valid witness for $\pi_2$ and can be retrieved as soon as $P_0$ publishes $\mathsf{tx_{swp(\mathbb{B})}}$, allowing $P_1$ to start force opening $C_1$. \\
We have that $T_0 = s(\mathbb{A}.\mathsf{ctime} + \mathbb{B}.\mathsf{ctime})$ with $s$ being a scaling factor $s > 2$, assume $P_0$ waits until exactly $T_0/2$ before publishing $\mathsf{tx_{swp(\mathbb{B})}}$: $P_1$ force opens $C_1$ in $T_1 = \mathbb{B}.\mathsf{ctime})$ time, retrieves $\mathsf{sk_{frz0}}$ to sign and publish $\mathsf{tx_{swp(\mathbb{A})}}$ transferring $\mathsf{amnt_a}$ from $\mathsf{pk_{frz(\mathbb{A})}}$ to $\mathsf{pk_{swp(\mathbb{A})}}$. The transaction will be confirmed in $\mathbb{A}.\mathsf{ctime}$ and the whole swapping process from $P_1$ completes in $\mathbb{A}.\mathsf{ctime} + \mathbb{B}.\mathsf{ctime} < \frac{T_0}{2}$, thus if $P_0$ posts $\mathsf{tx_{swp(\mathbb{B})}}$ $P_1$ is guaranteed to successfly swap their assets resulting in $P_1$ holding $\mathsf{amnt_a}$ on $\mathsf{pk_{swp(\mathbb{A})}}$. \\

Now assume instead that some routine in the protocol execution timed out or faulted, resulting in executing the refund branch: $P_1$ will generate a new key pair $(\mathsf{pk_{rfnd}}, \mathsf{sk_{rfnd}})$ on $\mathbb{B}$, and sign and publish


\section{Implementation and Evaluation}

\subsection{Implementation}

\todo[inline]{Write down note-worthy implementation details. At the very least, mention how building blocks are mentioned.}

\subsection{Performance Evaluation}

\todo[inline]{self explanatory}

\printbibliography


\end{document}
