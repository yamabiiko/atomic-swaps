% TeX root = atomic-swaps.tex

\section{Commit Transactions and Atomic Swaps}

\subsection{Commit Transactions}
CommitTx provides a minimal interface for implementing conditional asset transfers on-chain without requiring general-purpose scripting. It enables locking funds under flexible spending conditions that can change over time, thereby allowing time-sensitive contracts such as atomic swaps or escrows.

We note that providing a fully universal definition of the CommitTx primitive is challenging due to the diversity in transaction models across cryptocurrencies. In particular, fundamental differences between UTXO-based (e.g., Bitcoin, MimbleWimble) and account-based (e.g., Ethereum, ZCash Sapling) systems lead to distinct transaction semantics and interface requirements. As a result, a single formalization of CommitTx that universaly applies to all transaction schemes would either be overly abstract or fail to capture critical implementation details. Nevertheless, the underlying concept of CommitTx  namely, conditional asset ownership based on timeouts —remains simple and expressive. In practice, this functionality can be readily adapted to different ledger models with modest modifications to fit the specifics of the transaction scheme and primitives in use.

A CommitTx-account operates in two phases:
\begin{itemize}
	\item Commit Phase: The user locks a given amount of coins into a special account defined by a commitment to:
	\begin{itemize}
		\item A main secret key $\mathsf{sk}_0$

		\item A set of auxiliary secret keys $\mathsf{sk}_1, \dots, \mathsf{sk}_k$

		\item Two (or more) index sets $I_0, I_1 \subseteq [k]$ which define authorized key combinations for spending the funds

		\item A time threshold $T$
	\end{itemize}

The account's address (or tag) is deterministically derived from $\mathsf{sk}_0$ and can be publicly computed, preserving the binding nature of the commitment without revealing spending conditions.

\item Reveal Phase: Depending on whether a transaction is issued before or after time $T$, different subsets of auxiliary keys are required:

	\begin{itemize}
		\item Before time $T$: The account can be spent using $\mathsf{sk}_0$ and the auxiliary keys indexed by $I_0$

		\item After time $T$: The spending requires $\mathsf{sk}_0$ and keys indexed by $I_1$

	\end{itemize}
This time-dependent spending rule supports two disjoint execution paths—ideal for use in atomic swap protocols where one party should be able to claim funds within a deadline, and the other should recover them afterward if the protocol fails to complete.
\end{itemize}


\subsection{Commit-Transaction-based Atomic Swaps}

\begin{figure}[H]
    \begin{pchstack}[center, boxed]
    \pseudocode{
        P_0(\mathsf{ssk_{\mathbb{A}}},\mathsf{rsk_{\mathbb{A}}},\mathsf{tsk_{\mathbb{B}}}) \qquad \qquad P_1(\mathsf{ssk_{\mathbb{B}}},\mathsf{rsk_{\mathbb{B}}},\mathsf{tsk_{\mathbb{A}}}) \\[0.1\baselineskip ][\hline] 
        \<\< \\[-0.4\baselineskip ]
        \mathcal{S_\mathbb{A}} := (\mathsf{ssk}_\mathbb{A}, \mathsf{rsk}_\mathbb{A}, \mathsf{tsk}_\mathbb{A}, \mathsf{accd}_\mathbb{A}) \\
        \mathsf{(tx_\mathbb{A}, TK_\mathbb{A})} := \mathsf{TxGen_\mathbb{A}}(\mathsf{st},P,R,\mathcal{S},\mathcal{T}) \\
        \mathcal{S_\mathbb{B}} := (\mathsf{ssk}_\mathbb{B}, \mathsf{rsk}_\mathbb{B}, \mathsf{tsk}_\mathbb{B}, \mathsf{accd}_\mathbb{B}) \\
        \mathsf{(tx_\mathbb{B}, TK_\mathbb{B})} := \mathsf{TxGen_\mathbb{B}}(\mathsf{st},P,R,\mathcal{S},\mathcal{T}) \\
        \mathbf{output} \: \mathsf{(tx_\mathbb{A} \oplus \mathsf{tx_\mathbb{B}}, TK_\mathbb{A})} \: \mathbf{to} \: P_1 \\
        \mathbf{output} \: \mathsf{(tx_\mathbb{B}, TK_\mathbb{B})} \: \mathbf{to} \: P_0 \\
    }
    \end{pchstack}
    \caption{Protocol definition of 2PC $\Gamma_{\mathsf{CommitTx}}$}
    \end{figure}
    
    
    \begin{figure}[H]
    \begin{minipage}[t]{0.5\textwidth}
    \begin{pchstack}[boxed]
    \pseudocode{
        \text{Global input} \:\: (T, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
        \mathsf{(rmpk, rmsk)} \gets \mathsf{KGen}_\mathsf{A}(\mathsf{pp}) \\
        \mathcal{S}_0 := \{(\mathsf{ssk}_\mathsf{A}, \perp, \perp, (\mathsf{amnt_a}, \perp))\} \\
        \mathcal{T}_0 := \{(\mathsf{smpk}_\mathsf{A}, \mathsf{tmpk}_\mathsf{A}, \mathsf{rmpk}_\mathsf{A}, (\mathsf{amnt_a}, T_0))\} \\
        \mathsf{(tx_0, TK_0)}_\mathbb{A} := \mathsf{TxGen_\mathbb{A}}(\mathsf{st},P,R,\mathcal{S}_0,\mathcal{T}_0) \\
        (\_, \mathsf{st}') := \mathsf{Vf}_\mathbb{A}(\mathsf{tx_0}) \\
        \mathsf{send}(\mathsf{(tx_0, TK_0)}_\mathbb{A}) \\
        \mathsf{\textbf{select}} \:\: \{ \\
        \quad \mathsf{\textbf{wait}} \:\: \{ \\
        \qquad \mathsf{timeout}(T_0) \\
        \quad \} \\
        \quad \mathsf{\textbf{wait}} \:\: \{ \\
        \qquad \mathsf{receive}(\mathsf{(tx_0, TK_0)}_\mathbb{B}) \\
        \qquad (\mathsf{res}, \mathsf{st}') := \mathsf{Vf}_\mathbb{B}(\mathsf{tx_0}) \\
        \qquad \mathsf{\textbf{if}} \:\: \mathsf{res} \neq 1 \\ % verify that commit transaction is valid and accepted
        \qquad \quad \mathsf{\textbf{return}} \perp \\
        \qquad (\mathsf{tx_1, TK_1}) \gets \Gamma.\mathsf{CommitTx}(\mathsf{ssk_\mathbb{A}}, \mathsf{rsk_\mathbb{A}}, \mathsf{tsk_\mathbb{B}}) \\
        \qquad (\mathsf{res}, \mathsf{st}') := \mathsf{Vf}_\mathbb{B}(\mathsf{tx_1}) \\
        \qquad \mathsf{\textbf{if}} \:\: \mathsf{res} \neq 1 \\ % verify that commit transaction is valid and accepted
        \qquad \quad \mathsf{\textbf{return}} \perp \\
        \quad \} \\
        \} \\
    }
    \end{pchstack}
    \end{minipage}%
    \hspace{0.4cm}
    \begin{minipage}[t]{0.5\textwidth}
    \begin{pchstack}[boxed]
    \pseudocode{
        \text{Global input} \:\: (T, \mathsf{amnt_a}, \mathsf{amnt_b},\mathbb{A}, \mathbb{B}) \\[0.1\baselineskip ][\hline] \\
        \mathsf{(rmpk, rmsk)} \gets \mathsf{KGen}_\mathsf{B}(\mathsf{pp}) \\
        \mathcal{S}_0 := \{(\mathsf{ssk}_\mathsf{B}, \perp, \perp, (\mathsf{amnt_b}, \perp))\} \\
        \mathcal{T}_0 := \{(\mathsf{smpk}_\mathsf{B}, \mathsf{tmpk}_\mathsf{B}, \mathsf{rmpk}_\mathsf{B}, (\mathsf{amnt_b}, T_1))\} \\
        \mathsf{(tx_0, TK_0)}_\mathbb{B} := \mathsf{TxGen_\mathbb{B}}(\mathsf{st},P,R,\mathcal{S}_0,\mathcal{T}_0) \\
        (\_, \mathsf{st}') := \mathsf{Vf}_\mathbb{B}(\mathsf{tx_0}) \\
        \mathsf{send}(\mathsf{(tx_0, TK_0)}_\mathbb{B}) \\
        \mathsf{\textbf{select}} \:\: \{ \\
        \quad \mathsf{\textbf{wait}} \:\: \{ \\
        \qquad \mathsf{timeout}(T_1) \\
        \quad \} \\
        \quad \mathsf{\textbf{wait}} \:\: \{ \\
        \qquad \mathsf{receive}(\mathsf{(tx_0, TK_0)}_\mathbb{A}) \\
        \qquad (\mathsf{res}, \mathsf{st}') := \mathsf{Vf}_\mathbb{A}(\mathsf{tx_0}) \\
        \qquad \mathsf{\textbf{if}} \:\: \mathsf{res} \neq 1 \\ % verify that commit transaction is valid and accepted
        \qquad \quad \mathsf{\textbf{return}} \perp \\
        \qquad (\mathsf{lk, TK_1}) \gets \Gamma.\mathsf{CommitTx}(\mathsf{ssk_\mathbb{B}}, \mathsf{rsk_\mathbb{B}}, \mathsf{tsk_\mathbb{A}}) \\
        \qquad (\mathsf{res}, \mathsf{st}') := \mathsf{Vf}_\mathbb{B}(\mathsf{tx_1}) \\
        \qquad \mathsf{\textbf{if}} \:\: \mathsf{res} \neq 1 \\ % verify that commit transaction is valid and accepted
        \qquad \quad \mathsf{\textbf{return}} \perp \\
        \quad \} \\
        \} \\
    }
    \end{pchstack}
    \end{minipage}%
    \caption{Full protocol execution for $P_0$ and $P_1$, respectively left and right}
    \end{figure}

\subsection{Comparison with HTLC-based Atomic Swaps}

A Hash Time-Lock Contract (HTLC) is a contract that enables conditional payment based on the revelation of a cryptographic secret within a certain time window. Formally, an HTLC is characterized by a tuple  $(\mathsf{amnt_a}, h, T, \mathsf{pk_0}, \mathsf{pk_1})$ where
\begin{itemize}
	\item $\mathsf{amnt_a}$ denotes the amount of $\mathsf{a}$ assets to be exchanged
	\item $h$ is the hash of a secret value $r$, i.e., $h = \mathcal{H}(r)$ for some cryptographic hash function $\mathcal{H}$
	\item $T$ is a timelock parameter, typically a block height or timestamp, indicating the deadline after which funds can be refunded
	\item $\mathsf{pk_0}$ is the public key of the sender (who can reclaim the funds after the timeout).
	\item $\mathsf{pk_1}$ is the public key of the intended recipient (who can claim the funds upon presenting the correct preimage $r$ before the timeout).
\end{itemize}


The HTLC transfers $\mathsf{amnt_a}$ to $\mathsf{pk_1}$ if invoked before timeout $T$ with input value $r$ such that $\mathcal{H}(r) = h$. 
If the contract is invoked after timeout $T$, it refunds the assets $\mathsf{amnt_a}$ to $\mathsf{pk_0}$ unconditionally.

Using HTLCs as a building block, an atomic swap protocol can be constructed as follows: \\
1) Alice chooses $r$, computes $h = \mathcal{H}(r)$, transfers $\mathsf{amnt_a}$ into an $(\mathsf{amnt_a}, h, T_0, \mathsf{pk_0}, \mathsf{pk_1})$ on blockchain $\mathbb{A}$ and sends $h,T$ to Bob. \\
2) Bob finishes the setup of the exchange by choosing a time $T_1 < T_0$ and transferring his $\mathsf{amnt_b}$ assets into an HTLC$(\mathsf{amnt_b}, h, T_1, \mathsf{pk_{tx}}, \mathsf{pk_{rx}})$ on blockchain $\mathbb{B}$.

HTLCs serve as the core building block in many atomic swap protocols. A standard two-party protocol between Alice and Bob proceeds as follows:

Alice chooses a uniformly random secret value $r$, computes $h = \mathcal{H}(r)$, and initiates an HTLC on blockchain $\mathbb{A}$ locking $\mathsf{amnt_a}$ to Bob under the tuple $(\mathsf{amnt_a}, h, T_0, \mathsf{pk}\text{Alice}, \mathsf{pk}\text{Bob})$. She then sends $(h, T_0)$ to Bob.

Bob selects a smaller timeout $T_1 < T_0$ and sets up an HTLC on blockchain $\mathbb{B}$ locking his $\mathsf{amnt_b}$ to Alice under $(\mathsf{amnt_b}, h, T_1, \mathsf{pk}\text{Bob}, \mathsf{pk}\text{Alice})$.

Alice redeems the funds from Bob’s HTLC on $\mathbb{B}$ by revealing $r$. Since transactions on public blockchains are visible, Bob can then observe $r$ on-chain and use it to redeem the funds from Alice’s HTLC on $\mathbb{A}$ before her timeout $T_0$.

This protocol ensures atomicity: either both parties receive their respective assets, or after the timeout, each party reclaims their original funds.

While HTLCs are widely used in practice, especially in early cross-chain systems and off-chain protocols such as the Lightning Network, they suffer from several critical limitations, especially when applied in a privacy-preserving or cross-paradigm setting.

\paragraph*{Compatibility of hash functions}
HTLC-based atomic swaps require both blockchains involved to support the same hash function. For instance, if chain $\mathbb{A}$ supports SHA-256 and chain $\mathbb{B}$ supports Blake2, an HTLC constructed with a hash $h = \mathcal{H}(r)$ cannot be replicated on the second chain unless both parties can compute and verify the same preimage relation. One possible workaround is to have Alice compute $h = \mathcal{H}(r)$ and $h' = \mathcal{H}'(r)$ and publish a non-interactive zero-knowledge (NIZK) proof that both hashes are computed from the same preimage. However, this increases protocol complexity and setup cost, and depends on the availability of NIZK-friendly primitives on both chains.
Since the same preimage $r$ is reused on both chains, an external observer can trivially link the two transactions, breaking the unlinkability that privacy-preserving systems aim to provide. A workaround—such as committing to a shifted value $r + r'$ with an accompanying NIZK proof—adds cryptographic overhead and requires careful implementation to avoid privacy leaks.
\paragraph*{(In)compatibility with private ledgers}
Many privacy-preserving cryptocurrencies, such as Monero or Zcash, do not support expressive scripting or global hash preimage verifiability. Even when HTLCs are theoretically implementable (e.g., in a limited form over RingCT), their transaction structure becomes easily distinguishable from standard private transfers, harming plausible deniability. In such cases, the protocol becomes asymmetric: the public-chain participant must move first, revealing the preimage, which the private-chain user can then observe off-chain—this violates the symmetry typically desired in fair exchange protocols.
\paragraph*{Miner incentives attacks} HTLCs may also suffer from incentive misalignments, particularly in adversarial mining environments. Miners observing the hash preimage during the redemption phase may attempt to front-run or extract value, especially when the reward from a successful claim is higher than the block reward or other fees. These risks have been documented in Kolluri et al., 2022, which explores protocol designs vulnerable to such "griefing" attacks in HTLC settings.
\newpage
