% TeX root = atomic-swaps.tex

\section{Commit Transactions and Atomic Swaps}

\subsection{Commit Transactions}
The commit transaction primitive offers a lightweight and expressive mechanism for implementing conditional, time-sensitive asset transfers directly on-chain, without requiring a general-purpose scripting environment. This functionality enables users to lock funds under epoch-dependent spending conditions, supporting contract patterns such as atomic swaps, escrows, and delayed claims—all of which rely on time-based control over asset ownership. \\
We note that providing a fully universal definition of a commit transaction primitive is challenging due to the diversity of transaction models across blockchain systems. In particular, fundamental differences between UTXO-based (e.g., Bitcoin, MimbleWimble) and account-based (e.g., Ethereum, ZCash Sapling) systems lead to distinct transaction semantics and interface requirements. As a result, a single formalization of commit transactions that universaly applies to all transaction schemes would either be overly abstract or would need to be tailored closely to each specific model. Nevertheless, the underlying concept of commit transactions - namely, timeout conditional asset ownership — remains simple and expressive. In practice, this functionality can be readily instantiated in various ledger models with modest modifications to fit the specifics of the transaction scheme and primitives in use. \vspace{0.3em} \\
The functionality of a commit transaction can be logically divided into two phases: Commit Phase and Reveal Phase, described as follows: \\
\textbf{Commit Phase}: The user locks a given amount of coins into a special account defined by a commitment to:
    \begin{itemize}
        \item A main secret key $\mathsf{sk}_0$
	\item A set of auxiliary secret keys $\mathsf{sk}_1, \dots, \mathsf{sk}_k$
	\item Two (or more) index sets $I_0, I_1 \subseteq [k]$ which define the required authorized key combinations for spending the funds
	\item A time threshold $T$, denoting an epoch after which the ownership of the accounts transitions.
    \end{itemize}
\textbf{Reveal Phase}: Depending on whether a transaction is issued before or after the epoch threshold $T$, different subsets of auxiliary keys are required:
\begin{itemize}
    \item Before time $T$: The account can be spent using $\mathsf{sk}_0$ and the auxiliary keys indexed by $I_0$
    \item After time $T$: The spending requires $\mathsf{sk}_0$ and keys indexed by $I_1$
\end{itemize}
This time-dependent control structure enables the definition of disjoint execution paths, ensuring that only authorized parties can redeem the funds within their designated time windows. For example, in an atomic swap protocol, one party may claim the funds by providing the required keys before a deadline, while the other party regains control if the swap fails and the deadline elapses.

\subsection{Commit-Transaction-based Atomic Swaps}
In this section we construct a protocol that realizes atomic swaps on a generic blockchain interface supporting commit transactions.

\subsubsection{Blockchain syntax}

\definition, A blockchain system supporting confidential constructions consists of the following algorithms, whose interfaces are defined as follows.
\begin{itemize}[topsep=0pt, itemsep=0pt, leftmargin=2em]
    \item $\mathbf{0/1} \gets \mathbf{TxPub}(\tx)$: publishes the transaction $\tx$. Outputs 1 if the transaction is accepted, 0 otherwise.
    \item $\mathbf{tx}  \gets \mathbf{TxGen}(\st, \{ \pk, \sk \}_S, \pk_T, \amnt)$: creates a signed transaction transferring $\amnt$ to $\pk_T$ from an account defined by the set $\{ \pk, \sk \}_S$.
\item $\mathbf{0/1} \gets \mathbf{CommitTx}(\st, \{ \pk, \sk \}_S, \mathsf{pk}_T, \{ \pk \}_0, \{ \pk \}_1, T, \amnt)$: creates a commit transaction transferring $\mathsf{amnt}$ from $\mathsf{ac}_S$ to a commit-based account defined by the main public key $\pk_T$, two index sets of public keys $\{ \pk \}_0, \{ \pk \}_1$ and a timeout $T$.
    \item $\mathbf{0/1} \gets \mathbf{TxVf}(\st, \tx)$: verifies the validity of the transaction based on the given state. Outputs 1 if the verification succeeds, 0 otherwise.
    \item $\mathsf{st} \gets \mathbf{GetState}$: gets the latest blockchain state, which encodes the set of accounts, verified transactions and current epoch of the blockchain.
    \item $\mathsf{time} \gets \mathbf{TimeExt}$: extracts the epoch from the state.
\end{itemize}

We require the standard safety and liveness security properties for the blockchains.

\begin{figure}[H]
    \begin{pchstack}[center, boxed]
    \pseudocode{
	    P_0((\pkm, \skm)_\bca,  (\pkc, \skc)_\bcb, \mathsf{\pk_{\mathsf{s}, \bcb}}) \qquad \qquad P_1((\pkm, \skm)_\bcb,  (\pkc, \skc)_\bca, \mathsf{\pk_{\mathsf{s}, \bca}}) \\[0.1\baselineskip ][\hline] 
        \<\< \\[-0.4\baselineskip ]
	\mathbf{assert} \: (\st_\bcb, \st_\bca, \amnt_\bcb,  \amnt_\bca)^0 = (\st_\bcb, \st_\bca, \amnt_\bcb,  \amnt_\bca)^1 \\
	\tx_{\mathsf{s}, \bcb} := \mathsf{TxGen_\bcb}(\st, \{ (\pkm^1, \skm^1), (\pkc^0, \skc^0) \}, \pks^0, \amnt) \\
	\mathbf{assert} \: \mathsf{TxVf}_\bcb(\st, \tx_{\mathsf{s}}) \\
	\tx_{\mathsf{s}, \bca} := \mathsf{TxGen_\bca}(\st, \{ (\pkm^0, \skm^0), (\pkc^1, \skc^1) \}, \pks^1, \amnt) \\
	\mathbf{assert} \: \mathsf{TxVf}_\bca(\st, \tx_{\mathsf{s}}) \\
	\mathsf{lk} \gets \mathcal{H}(\tx_{\mathsf{s}, \bcb}) \oplus \tx_{\mathsf{s}, \bca} \\
        \mathbf{output} \: \mathsf{lk} \: \mathbf{to} \: P_1 \\
        \mathbf{output} \: \tx_{\mathsf{s}, \bcb} \: \mathbf{to} \: P_0
    }
    \end{pchstack}
    \caption{Protocol definition of 2PC $\Gamma_{\mathsf{CommitTx}}$}
    \end{figure}
    \begin{figure}[H]
    \begin{minipage}[t]{0.5\textwidth}
    \begin{pchstack}[boxed]
    \pseudocode{
	\text{Party input} \:\: (\pki, \ski)_{\bca}, (\pks, \sks)_{\bcb} \\[0.1\baselineskip ][\hline]
	(\skm, \pkm)^0 \gets \mathsf{KGen}_\bca(\pp) \\
	(\skr, \pkr)^0 \gets \mathsf{KGen}_\bca(\pp) \\
	(\skc, \pkc)^0 \gets \mathsf{KGen}_\bcb(\pp) \\
	\mathsf{send}(\pk_{\mathsf{c}, \bcb}^0) \\
	\pk_{\mathsf{c}, \bca}^1 \gets \mathsf{receive} \\
	\tx_{\mathsf{r}, \bca} \gets \mathsf{CommitTx}_\bca(\st, (\pki, \ski)^0, \pkm^0, \{ \pkc^1 \}, \{ \pkr^1 \}, T_0, \amnt) \\
	\mathsf{TxPub}_\bca(\tx_\mathsf{r}) \\
        \mathsf{\textbf{select}} \: \{ \\
        \quad \mathsf{\textbf{wait}} \: \{ \\
	\qquad \textbf{do} \: \st \gets \mathsf{GetState}_\bca \\ 
	\qquad \textbf{while} \: \mathsf{TimeExt}_\bca(\st) < T_0 \\
	\qquad \tx_{\mathsf{r}} \gets \mathsf{TxGen_\bca}(\st, \{ (\pkm, \skm)^0, (\pkr, \skr)^0 \}, \pki^0, \amnt) \\
	\qquad \mathsf{TxPub}_\bca(\tx_{\mathsf{r}}) \\
        \quad \} \\
        \quad \mathsf{\textbf{wait}} \:\: \{ \\
	\qquad \mathsf{send}(\tx_{\mathsf{r}, \bca}) \\
	\qquad \mathsf{tx_{\mathsf{r}, \bcb}} \gets \mathsf{receive} \\
	\qquad \textbf{assert} \: \mathsf{TxVf}_\bcb(\mathsf{tx}_\bcb) \\
	\qquad \textbf{assert} \: (\pk_{\mathsf{c}, \bcb}^0, \amnt_\bcb) \in \mathsf{tx_{\mathsf{r}, \bcb}} \\
	\qquad \tx_{\mathsf{s}, \bcb} \gets \Gamma.\mathsf{Swap}(\mathsf{\pk_{\mathsf{m}, \bca}^0}, \pk_{\mathsf{r}, \bca}^0, \pk_{\mathsf{c}, \bcb}^0) \\
	\qquad \textbf{assert} \: \mathsf{TxPub}_\bcb(\tx_{\mathsf{s}}) \\
        \quad \} \\
        \} \\
    }
    \end{pchstack}
    \end{minipage}%
    \hspace{0.7cm}
    \begin{minipage}[t]{0.5\textwidth}
    \begin{pchstack}[boxed]
    \pseudocode{
	\text{Party input} \:\: (\pki, \ski)_{\bcb}, (\pks, \sks)_{\bca} \\[0.1\baselineskip ][\hline] 
	(\skm, \pkm)^1,  \gets \mathsf{KGen}_\bcb(\pp) \\
	(\skr, \pkr)^1 \gets \mathsf{KGen}_\bcb(\pp) \\
	(\skc, \pkc)^1\gets \mathsf{KGen}_\bca(\pp) \\
	\mathsf{send}(\pk_{\mathsf{c}, \bca}^1) \\
	\pk_{\mathsf{c}, \bcb}^0 \gets \mathsf{receive} \\
	\tx_\bcb \gets \mathsf{CommitTx}_\bcb(\st, (\pki, \ski)^1, \pkm^1 , \{ \pkc^0 \}, \{ \pkr^1 \}, T_1, \amnt) \\
	\mathsf{TxPub}_\bcb(\tx_\bcb) \\
        \mathsf{\textbf{select}} \: \{ \\
        \quad \mathsf{\textbf{wait}} \: \{ \\
	\qquad \textbf{do} \: \st \gets \mathsf{GetState}_\bcb \\ 
	\qquad \textbf{while} \: \mathsf{TimeExt}_\bcb(\st) < T_1 \\
	\qquad \tx_{\mathsf{r}} \gets \mathsf{TxGen_\bcb}(\st, \{ (\pkm, \skm)^1, (\pkr, \skc)^1 \}, \pki^1, \amnt) \\
	\qquad \mathsf{TxPub}_\bcb(\tx_{\mathsf{r}}) \\
        \quad \} \\
        \quad \mathsf{\textbf{wait}} \:\: \{ \\
	\qquad \mathsf{send}(\tx_{\mathsf{r}, \bcb}) \\
	\qquad \mathsf{tx_{\mathsf{r}, \bca}} \gets \mathsf{receive} \\
	\qquad \textbf{assert} \: \mathsf{TxVf}_\bca(\mathsf{tx}_\mathsf{r}) \\
	\qquad \textbf{assert} \: (\pk_{\mathsf{c}, \bca}^1\, \amnt_\bca) \in \mathsf{tx_{\mathsf{r}, \bca}} \\
	\qquad \mathsf{lk} \gets \Gamma.\mathsf{Swap}(\mathsf{\pk_{\mathsf{m}, \bcb}^1}, \pk_{\mathsf{r}, \bcb}^1, \pk_{\mathsf{c}, \bca}^1) \\
	\qquad \textbf{do} \: \st \gets \mathsf{GetState}_\bcb \\
	\qquad \textbf{while} \: \not\exists \: \mathsf{tx} \in \st \mid (\pk_{\mathsf{c}, \bcb}^1, \pk_{\mathsf{m}, \bcb}^0) \in \mathsf{tx} \\
	\qquad \tx_{\mathsf{s}, \bcb} := \mathsf{tx} \in \st \mid (\pk_{\mathsf{c}, \bcb}^1, \pk_{\mathsf{m}, \bcb}^0) \in \mathsf{tx} \\
	\qquad \tx_{\mathsf{s}, \bca} := \mathsf{lk} \oplus  \tx_{\mathsf{s}, \bcb} \\
	\qquad \textbf{assert} \: \mathsf{TxPub}_\bca(\tx_{\mathsf{s}}) \\
        \quad \} \\
        \} \\
    }
    \end{pchstack}
    \end{minipage}%
    \caption{Full protocol execution for $P_0$ and $P_1$, respectively left and right}
    \end{figure}

\subsection{Comparison with HTLC-based Atomic Swaps}

\newpage
